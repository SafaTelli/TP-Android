{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TP Android - GL4 Ce cours comporte 6 s\u00e9ances de travaux pratiques: TP1: Cr\u00e9ation des interfaces graphiques et navigation TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : RecyclerView TP3: Cr\u00e9ation des Fragments TP4: Base de donn\u00e9es interne / Firebase TP5: Connexion \u00e0 des services web REST TP6: MVVM avec Android","title":"Introduction"},{"location":"#tp-android-gl4","text":"Ce cours comporte 6 s\u00e9ances de travaux pratiques: TP1: Cr\u00e9ation des interfaces graphiques et navigation TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : RecyclerView TP3: Cr\u00e9ation des Fragments TP4: Base de donn\u00e9es interne / Firebase TP5: Connexion \u00e0 des services web REST TP6: MVVM avec Android","title":"TP Android - GL4"},{"location":"tp0/","text":"Initiation au langage Kotlin Objectifs du TP Dans ce TP nous allons nous familiariser avec le langage kotlin Langage Kotlin Kotlin a \u00e9t\u00e9 d\u00e9velopp\u00e9 par JetBrains dans l\u2019objectif de pallier les limitations qu\u2019imposait Java dans le d\u00e9veloppement de ses diff\u00e9rents produits. Kotlin est un langage de programmation \"statiquement typ\u00e9\" supportant n\u00e9anmoins \"l\u2019inf\u00e9rence de type\" gr\u00e2ce \u00e0 son compilateur. Kotlin supporte la \"programmation orient\u00e9e objet\" et la \"programmation fonctionnelle\". Kotlin est open source, supporte la plupart des IDE et fonctionne sur la majorit\u00e9 des plateformes Java actuelles (o\u00f9 le bytecode JVM est accept\u00e9) En 2017, Google a annonc\u00e9 lors de sa conf\u00e9rence Google I/O, que kotlin est d\u00e9sormais son langage pr\u00e9f\u00e9r\u00e9 pour les d\u00e9veloppeurs d'applications Android. Premi\u00e8re application kotlin Lancer AndroidStudio File -> New -> New Project S\u00e9lectionner \"No Activity\" (pour une application sur le terminal) Choisir le nom du projet (ici Hello) Le nom de package (ici com.gl4.tp) Le r\u00e9pertoire du projet Langage (Kotlin) File -> New ->Kotlin Class/File pour ajouter le fichier source Choisir le nom du fichier (Hello.kt) Le programme doit contenir fonction main suivante : fun main ( argv : Array < String > )){ print ( \"Hello\" ) } 11. Ex\u00e9cuter le programme en choisisant : Run 'HelloKt' Voici le r\u00e9sultat : Les variables La mention du type d'une variable n'est pas obligatoire en Kotlin. Le compilateur de Kotlin poss\u00e8de une fonctionnalit\u00e9 appel\u00e9e \"l\u2019inf\u00e9rence de type\", ou \"type inference\", en anglais. Pour que cela soit plus parlant, comprenez par \"inf\u00e9rence\" la notion de \"d\u00e9duction\" ! . Kotlin se voulant \u00eatre un langage tr\u00e8s intelligent, ses d\u00e9veloppeurs ont souhait\u00e9 lui offrir les avantages de lisibilit\u00e9 des langages \"dynamiquement typ\u00e9s\", mais sans leurs inconv\u00e9nients. En effet, pour Kotlin, ce sera au moment de la compilation (et non au moment de l\u2019ex\u00e9cution) que les types de vos variables seront automatiquement d\u00e9duit. val name : String = \"Mohamed\" val age : Int = 27 val isDeveloper : Boolean = true Equivaut \u00e0 : val name = \"Mohamed\" val age = 27 val isDeveloper = true Les types nullables Kotlin est un langage dit \"s\u00fbr\". Derri\u00e8re cet adjectif r\u00e9confortant se cache en r\u00e9alit\u00e9 un ensemble de fonctionnalit\u00e9s am\u00e9liorant la s\u00fbret\u00e9 du langage, dont la fameuse \" Null Safety \". Exemple concret : Copier le code suivant dans fonction main() cr\u00e9e au d\u00e9part : var message : String ? = \"My message can possibly be null !\" message . upperCase () Comme vous le voyez sur l\u2019exemple ci-dessus, nous avons d\u00e9clar\u00e9 la variable message comme pouvant \"possiblement\" contenir une valeur nulle. Puis, lorsque nous souhaitons ensuite acc\u00e9der \u00e0 sa m\u00e9thode upperCase() , le compilateur Kotlin nous souligne en rouge le point pr\u00e9c\u00e9dant cette m\u00e9thode pour nous dire que cela est impossible, car la variable peut \u00eatre possiblement nulle. Pour g\u00e9rer une variable possiblement nulle il faut utiliser le point d\u2019interrogation afin d\u2019appeler une de ses m\u00e9thodes de mani\u00e8re s\u00e9curis\u00e9e. D\u00e8s lors, si jamais la variable est \u00e9gale \u00e0 nulle, la m\u00e9thode ne sera tout simplement pas appel\u00e9e ! En revanche, si la variable contient bien une valeur, alors la m\u00e9thode sera appel\u00e9e et ex\u00e9cut\u00e9e. var message : String ? = \"My message can possibly be null !\" message . upperCase () L' op\u00e9rateur !!. l'op\u00e9rateur d'assertion non nul (!!) convertit toute valeur en un type non nul et l\u00e8ve une exception si la valeur est nulle. Vous pouvez \u00e9crire x!!, et cela renverra une valeur non nulle de x (par exemple, une cha\u00eene) ou lancera un NullPointerException si x est null : val ville = personnel [ i ]!! . adresse !! . city //si personnel[i] ou adresse est \u00e9gale \u00e0 null alors NullPointerException, par contre city peut \u00eatre null L' op\u00e9rateur elvis ?: var s = savedInstanceState ? . getInt ( \"key\" ) ? : 0 Si la valeur de savedInstanceState?.getInt(\"key\") est un Int alors s prendra cette valeur, si la valeur de cette expression est null alors s prendra la valeur 0 Le mot cl\u00e9 lateinit Imaginez que vous ne souhaitiez pas initialiser votre variable imm\u00e9diatement apr\u00e8s sa d\u00e9claration, mais le faire un peu plus tard dans votre code (quand par exemple une page ou un \u00e9cran a termin\u00e9 de charger). Vous allez tout simplement utiliser le mot-cl\u00e9 lateinit (pour \"Late-Initialized\") permettant d\u2019indiquer \u00e0 Kotlin que vous \u00eates s\u00fbr et certain d\u2019initialiser la variable en question, un peu plus tard dans votre code : private lateinit var submitButton : Button Le symbole $ Kotlin nous permet de manipuler un peu plus simplement les variables de type String . Nous allons pouvoir, par exemple, utiliser le symbole $ afin de faire r\u00e9f\u00e9rence \u00e0 une variable locale directement \u00e0 l\u2019int\u00e9rieur d\u2019un autre String : val name = \"Mohamed\" print ( \"Hello $name\" ) Activit\u00e9 Copier le code suivant et le corriger : val hello = \"Hello\" hello = \"Hello world!\" println ( hello ) var toto : Int = \"Toto\" println ( toto ) var message : String ? = \"I\u2019m learning Kotlin!\" message = null println ( message . toString ()) Les fonctions Activit\u00e9 Ecrire une fonction qui prend 2 valeurs en param\u00e8tres et retourne leurs somme. Corriger cette fonction: fun sayMyName () { println ( \" $name \" ) } Simplifier cette fonction: fun sayHello (): String { return \"Hello\" } Les boucles Les listes En Kotlin, vous aurez la possibilit\u00e9 de cr\u00e9er tr\u00e8s facilement des listes de valeurs afin de lier diff\u00e9rentes donn\u00e9es entre elles. Nous allons ainsi pouvoir appeler les m\u00e9thodes g\u00e9n\u00e9riques suivantes : listOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et immuable. mutableListOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et muable. setOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et immuable. mutableSetOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et muable. // listOf val listOfNames = listOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => ERROR ! List is immutable // mutableListOf val listOfNames = mutableListOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => SUCCESS ! // setOf val setOfNames = setOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => ERROR ! Set is immutable // mutableSetOf val setOfNames = mutableSetOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => SUCCESS ! Info Sachez \u00e9galement qu\u2019il existe d\u2019autres m\u00e9thodes comme arrayOf pour cr\u00e9er un tableau de valeurs, et m\u00eame mapOf pour cr\u00e9er un dictionnaire de valeurs. Activit\u00e9 fun showList ( list : List < String > ){ // Compl\u00e9tez la fonction pour afficher les \u00e9l\u00e9ments de la liste } fun oddNumbersTo10 (){ // Compl\u00e9tez la fonction pour afficher les nombres impairs jusqu'\u00e0 10 } private val languages = // Cr\u00e9ez une liste ordonn\u00e9e de plusieurs languages de programation fun main ( args : Array < String > ) { println ( \"Languages :\" ) showList ( languages ) println ( \"Odd Numbers to 10 :\" ) oddNumbersTo10 () } Les choix et les conditions if ... else Toutes les structures de contr\u00f4le (\u00e0 l\u2019exception des boucles) sont des expressions , et pourront donc renvoyer une valeur. D\u2019ailleurs, en Kotlin, l\u2019op\u00e9rateur ternaire n\u2019existe plus : on pr\u00e9f\u00e9rera utiliser une condition if/else. var a = 10 var b = 12 val result = if ( a > b ){ a ++ a } else { b ++ b } print ( \"Result is : $result\" ) selon ... La fameuse switch de Java, existe en kotlin mais avec une autre identit\u00e9. Oubliez switch et utilisez \u00e0 la place le mot-cl\u00e9 when . val number = 15 when ( number ){ 1 -> print ( \"Un\" ) 2 -> print ( \"Deux\" ) 3 -> print ( \"Trois\" ) else -> print ( \"Inconnu\" ) } Activit\u00e9 Cr\u00e9er une fonction qui prend en param\u00e8tres deux entiers et un op\u00e9rateur ( +, -, /,*, %) et renvoit le r\u00e9sultat de l'op\u00e9ration. Tester la fonction. Les classes En Kotlin, la visibilit\u00e9 par d\u00e9faut de n\u2019importe quel \u00e9l\u00e9ment de votre code (variables, fonctions, classes, etc.) est public . Il existe 4 principaux modificateurs de visibilit\u00e9 pour les membres (variables, fonctions, etc.) d\u2019une classe : private : Un membre d\u00e9clar\u00e9 comme private sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9. protected : Un membre d\u00e9clar\u00e9 comme protected sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9 ET dans ses sous-classes (via l\u2019h\u00e9ritage). internal : Un membre d\u00e9clar\u00e9 comme internal sera visible par tous ceux du m\u00eame module. Un module est un ensemble de fichiers compil\u00e9s ensemble (comme une librairie Gradle ou Maven, par exemple). public : Un membre d\u00e9clar\u00e9 comme public sera visible partout et par tout le monde. Pour pouvoir personnaliser un getter() ou un setter() en kotlin, il faut utiliser les mots cl\u00e9s get() et set() dans le corps de la classe. Exemple : class User ( email : String , var password : String , var age : Int ){ var email : String = email get () { println ( \"User is getting his email.\" ); return field } set ( value ) { println ( \"User is setting his email\" ); field = value } } Si nous souhaitons d\u00e9finir la propri\u00e9t\u00e9 password comme \u00e9tant priv\u00e9e, nous pouvons le faire en rajoutant le mot-cl\u00e9 private devant sa d\u00e9claration : class User ( var email : String , private var passwird : String , var age : Int ) L'heritage en Kotlin, toutes les classes et leurs m\u00e9thodes sont \"ferm\u00e9es\" par d\u00e9faut. Vous ne pourrez donc pas h\u00e9riter d\u2019une classe ou red\u00e9finir ses m\u00e9thodes sans l\u2019autorisation explicite. Ainsi, il faut indiquer explicitement, avec au mot-cl\u00e9 open , si une classe ou une m\u00e9thode peut \u00eatre \"ouverte\" \u00e0 l\u2019h\u00e9ritage. Les modificateurs d\u2019acc\u00e8s disponibles en Kotlin (\u00e0 ne pas confondre avec les modificateurs de visibilit\u00e9!) : final : Classe/M\u00e9thode/Propri\u00e9t\u00e9 ne pouvant pas \u00eatre red\u00e9finie. C\u2019est l\u2019\u00e9tat par d\u00e9faut de tous les \u00e9l\u00e9ments en Kotlin. open : Classe/M\u00e9thode/Propri\u00e9t\u00e9 pouvant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s doit \u00eatre indiqu\u00e9 explicitement. abstract : Classe/M\u00e9thode/Propri\u00e9t\u00e9 devant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s peut \u00eatre utilis\u00e9 uniquement dans des classes abstraites. Et bien entendu, le mot-cl\u00e9 override sera utilis\u00e9 pour red\u00e9finir un \u00e9l\u00e9ment d\u2019une classe parente (ou d\u2019une interface). Les constructeurs multiples Pour cr\u00e9er un second constructeur, il faut utiliser le mot cl\u00e9 constructor Les classes de donn\u00e9es En Kotlin, nous pouvons d\u00e9finir une classe comme \u00e9tant destin\u00e9e \u00e0 contenir des mod\u00e8les de donn\u00e9es gr\u00e2ce au mot-cl\u00e9 data : data class User ( var email : String , var password : String , var isConnected : Boolean ) Gr\u00e2ce \u00e0 ce simple mot-cl\u00e9, le compilateur Kotlin impl\u00e9mentera pour nous les principales m\u00e9thodes utilis\u00e9es pour \"comparer\" et \"d\u00e9crire\" un objet contenant des donn\u00e9es comme les m\u00e9thodes toString() , hashCode() , equals() ou encore copy() . Function types Il est possible d'avoir les variables de type fonction (quicontiennent une r\u00e9f\u00e9rence vers une fonction) et il est possible de passer une fonction comme param\u00e8tre d'une autre fonction. fun appl ( a : List < Int > , b : List < Int > , f : ( Int , Int ) -> Int ) : MutableList < Int > { var r = mutableListOf < Int > () val s = if ( a . size < b . size ) a . size else b . size for ( i in 0. . s - 1 ) r . add ( f ( a [ i ] , b [ i ] ) ) return r } appl() prend comme param\u00e8tres deux listes de Int et le troisi\u00e8me param\u00e8tre f: (Int,Int)-> Int est une fonction qui prend deux Int et retourne un Int. La fonction appl() construit une nouvelle liste obtenue en appliquant f aux couples correspondants de listes a et b. fun fu ( i : Int , j : Int ) : Int { return i * i + j * j } val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) //passer une fonction en param\u00e8tre val res = appl ( p , q , :: fu ) //le nom de fonction pr\u00e9c\u00e9d\u00e9 par :: ou par NomClasse:: si la fonction est d\u00e9finie dans une classe Fonctions comme param\u00e8tres, lambda-expressions val res2 = appl ( p , q , { a , b -> a * b }) { a , b -> a * b } C'est une lambda expression qui d\u00e9signe une fonction sans nom avec les arguments a, b. Le compilateur d\u00e9duit le type de param\u00e8tres de la d\u00e9finition de appl(). Lambda expression avec le type de param\u00e8tres : { a : Int , b : Int -> val x = a - b x * x } La valeur de lambda expression est la derni\u00e8re valeur calcul\u00e9e dans le corps de la fonction. Si lambda expression est le dernier argument d'une fonction alors on peut la mettre en dehors des parenth\u00e8ses. val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) val res2 = appl ( p , q ) { a , b -> ( a - b ) * ( a - b ) } Travail \u00e0 rendre Exercice Dans Android Studio, cr\u00e9ez l\u2019application TP01. Suivez les instructions donn\u00e9es dans ce TP pour cr\u00e9er une application \u00e0 ex\u00e9cuter sur un terminal. Hello Pour voir si votre application est correctement g\u00e9n\u00e9r\u00e9e dans AndroidStudio mettre dans la fonction main() l\u2019affichage de \"Hello\" et tester si votre programme s\u2019ex\u00e9cute correctement. classe Point D\u00e9finir la classe Point qui correspond \u00e0 un point sur le, plan avec les coordonn\u00e9es enti\u00e8res x et y. La classe Point sera d\u00e9clar\u00e9 comme data class. distance \u00c9crire la fonction distance qui prend comme argument deux points et calcule la distance entre eux. On suppose que la distance entre les point p et q est |p.x \u2212 q.x| + |p.y \u2212 q.y| (donc c\u2019est un Int).. classe Rectangle La classe Rectangle repr\u00e9sente un rectangle sur le plan dont les sommets ont les coordonn\u00e9es enti\u00e8res. Un tel rectangle est d\u00e9finie de fa\u00e7o,n unique par deux de ses sommets, le sommet p en bas \u00e0 gauche et q en haut \u00e0 droite. \u00c9crire la classe Rectangle avec un constructeur qui prend comme param\u00e8tres les points p et q. Les valeurs par d\u00e9faut pour les deux points sont respectivement (0, 0) et (1, 1). Red\u00e9finir la m\u00e9thode toString() de Rectangle pour qu\u2019elle retourne \"p=$p q=$q\". D\u00e9finir dans main() un Array compos\u00e9e de plusieurs rectangles. Pour d\u00e9finir les rectangles utilisez aussi les valeurs par d\u00e9faut (un rectangles avec p et q par d\u00e9faut, un rectangle avec la valeur p par d\u00e9faut et q d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, un rectangle avec la valeur q par d\u00e9faut et p d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, etc.) Dans la classe Rectangle ajouter la m\u00e9thode surface qui retourne la surface de rectangle. Dans main afficher la surface de chaque rectangle qui est dans le tableau d\u00e9fini pr\u00e9c\u00e9demment.","title":"TP0: Intitiation au langage Kotlin"},{"location":"tp0/#initiation-au-langage-kotlin","text":"","title":"Initiation au langage Kotlin"},{"location":"tp0/#objectifs-du-tp","text":"Dans ce TP nous allons nous familiariser avec le langage kotlin","title":"Objectifs du TP"},{"location":"tp0/#langage-kotlin","text":"Kotlin a \u00e9t\u00e9 d\u00e9velopp\u00e9 par JetBrains dans l\u2019objectif de pallier les limitations qu\u2019imposait Java dans le d\u00e9veloppement de ses diff\u00e9rents produits. Kotlin est un langage de programmation \"statiquement typ\u00e9\" supportant n\u00e9anmoins \"l\u2019inf\u00e9rence de type\" gr\u00e2ce \u00e0 son compilateur. Kotlin supporte la \"programmation orient\u00e9e objet\" et la \"programmation fonctionnelle\". Kotlin est open source, supporte la plupart des IDE et fonctionne sur la majorit\u00e9 des plateformes Java actuelles (o\u00f9 le bytecode JVM est accept\u00e9) En 2017, Google a annonc\u00e9 lors de sa conf\u00e9rence Google I/O, que kotlin est d\u00e9sormais son langage pr\u00e9f\u00e9r\u00e9 pour les d\u00e9veloppeurs d'applications Android.","title":"Langage Kotlin"},{"location":"tp0/#premiere-application-kotlin","text":"Lancer AndroidStudio File -> New -> New Project S\u00e9lectionner \"No Activity\" (pour une application sur le terminal) Choisir le nom du projet (ici Hello) Le nom de package (ici com.gl4.tp) Le r\u00e9pertoire du projet Langage (Kotlin) File -> New ->Kotlin Class/File pour ajouter le fichier source Choisir le nom du fichier (Hello.kt) Le programme doit contenir fonction main suivante : fun main ( argv : Array < String > )){ print ( \"Hello\" ) } 11. Ex\u00e9cuter le programme en choisisant : Run 'HelloKt' Voici le r\u00e9sultat :","title":"Premi\u00e8re application kotlin"},{"location":"tp0/#les-variables","text":"La mention du type d'une variable n'est pas obligatoire en Kotlin. Le compilateur de Kotlin poss\u00e8de une fonctionnalit\u00e9 appel\u00e9e \"l\u2019inf\u00e9rence de type\", ou \"type inference\", en anglais. Pour que cela soit plus parlant, comprenez par \"inf\u00e9rence\" la notion de \"d\u00e9duction\" ! . Kotlin se voulant \u00eatre un langage tr\u00e8s intelligent, ses d\u00e9veloppeurs ont souhait\u00e9 lui offrir les avantages de lisibilit\u00e9 des langages \"dynamiquement typ\u00e9s\", mais sans leurs inconv\u00e9nients. En effet, pour Kotlin, ce sera au moment de la compilation (et non au moment de l\u2019ex\u00e9cution) que les types de vos variables seront automatiquement d\u00e9duit. val name : String = \"Mohamed\" val age : Int = 27 val isDeveloper : Boolean = true Equivaut \u00e0 : val name = \"Mohamed\" val age = 27 val isDeveloper = true","title":"Les variables"},{"location":"tp0/#les-types-nullables","text":"Kotlin est un langage dit \"s\u00fbr\". Derri\u00e8re cet adjectif r\u00e9confortant se cache en r\u00e9alit\u00e9 un ensemble de fonctionnalit\u00e9s am\u00e9liorant la s\u00fbret\u00e9 du langage, dont la fameuse \" Null Safety \". Exemple concret : Copier le code suivant dans fonction main() cr\u00e9e au d\u00e9part : var message : String ? = \"My message can possibly be null !\" message . upperCase () Comme vous le voyez sur l\u2019exemple ci-dessus, nous avons d\u00e9clar\u00e9 la variable message comme pouvant \"possiblement\" contenir une valeur nulle. Puis, lorsque nous souhaitons ensuite acc\u00e9der \u00e0 sa m\u00e9thode upperCase() , le compilateur Kotlin nous souligne en rouge le point pr\u00e9c\u00e9dant cette m\u00e9thode pour nous dire que cela est impossible, car la variable peut \u00eatre possiblement nulle. Pour g\u00e9rer une variable possiblement nulle il faut utiliser le point d\u2019interrogation afin d\u2019appeler une de ses m\u00e9thodes de mani\u00e8re s\u00e9curis\u00e9e. D\u00e8s lors, si jamais la variable est \u00e9gale \u00e0 nulle, la m\u00e9thode ne sera tout simplement pas appel\u00e9e ! En revanche, si la variable contient bien une valeur, alors la m\u00e9thode sera appel\u00e9e et ex\u00e9cut\u00e9e. var message : String ? = \"My message can possibly be null !\" message . upperCase ()","title":"Les types nullables"},{"location":"tp0/#l-operateur","text":"l'op\u00e9rateur d'assertion non nul (!!) convertit toute valeur en un type non nul et l\u00e8ve une exception si la valeur est nulle. Vous pouvez \u00e9crire x!!, et cela renverra une valeur non nulle de x (par exemple, une cha\u00eene) ou lancera un NullPointerException si x est null : val ville = personnel [ i ]!! . adresse !! . city //si personnel[i] ou adresse est \u00e9gale \u00e0 null alors NullPointerException, par contre city peut \u00eatre null","title":"L' op\u00e9rateur !!."},{"location":"tp0/#l-operateur-elvis","text":"var s = savedInstanceState ? . getInt ( \"key\" ) ? : 0 Si la valeur de savedInstanceState?.getInt(\"key\") est un Int alors s prendra cette valeur, si la valeur de cette expression est null alors s prendra la valeur 0","title":"L' op\u00e9rateur elvis ?:"},{"location":"tp0/#le-mot-cle-lateinit","text":"Imaginez que vous ne souhaitiez pas initialiser votre variable imm\u00e9diatement apr\u00e8s sa d\u00e9claration, mais le faire un peu plus tard dans votre code (quand par exemple une page ou un \u00e9cran a termin\u00e9 de charger). Vous allez tout simplement utiliser le mot-cl\u00e9 lateinit (pour \"Late-Initialized\") permettant d\u2019indiquer \u00e0 Kotlin que vous \u00eates s\u00fbr et certain d\u2019initialiser la variable en question, un peu plus tard dans votre code : private lateinit var submitButton : Button","title":"Le mot cl\u00e9 lateinit"},{"location":"tp0/#le-symbole","text":"Kotlin nous permet de manipuler un peu plus simplement les variables de type String . Nous allons pouvoir, par exemple, utiliser le symbole $ afin de faire r\u00e9f\u00e9rence \u00e0 une variable locale directement \u00e0 l\u2019int\u00e9rieur d\u2019un autre String : val name = \"Mohamed\" print ( \"Hello $name\" ) Activit\u00e9 Copier le code suivant et le corriger : val hello = \"Hello\" hello = \"Hello world!\" println ( hello ) var toto : Int = \"Toto\" println ( toto ) var message : String ? = \"I\u2019m learning Kotlin!\" message = null println ( message . toString ())","title":"Le symbole $"},{"location":"tp0/#les-fonctions","text":"Activit\u00e9 Ecrire une fonction qui prend 2 valeurs en param\u00e8tres et retourne leurs somme. Corriger cette fonction: fun sayMyName () { println ( \" $name \" ) } Simplifier cette fonction: fun sayHello (): String { return \"Hello\" }","title":"Les fonctions"},{"location":"tp0/#les-boucles","text":"","title":"Les boucles"},{"location":"tp0/#les-listes","text":"En Kotlin, vous aurez la possibilit\u00e9 de cr\u00e9er tr\u00e8s facilement des listes de valeurs afin de lier diff\u00e9rentes donn\u00e9es entre elles. Nous allons ainsi pouvoir appeler les m\u00e9thodes g\u00e9n\u00e9riques suivantes : listOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et immuable. mutableListOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et muable. setOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et immuable. mutableSetOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et muable. // listOf val listOfNames = listOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => ERROR ! List is immutable // mutableListOf val listOfNames = mutableListOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => SUCCESS ! // setOf val setOfNames = setOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => ERROR ! Set is immutable // mutableSetOf val setOfNames = mutableSetOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => SUCCESS ! Info Sachez \u00e9galement qu\u2019il existe d\u2019autres m\u00e9thodes comme arrayOf pour cr\u00e9er un tableau de valeurs, et m\u00eame mapOf pour cr\u00e9er un dictionnaire de valeurs. Activit\u00e9 fun showList ( list : List < String > ){ // Compl\u00e9tez la fonction pour afficher les \u00e9l\u00e9ments de la liste } fun oddNumbersTo10 (){ // Compl\u00e9tez la fonction pour afficher les nombres impairs jusqu'\u00e0 10 } private val languages = // Cr\u00e9ez une liste ordonn\u00e9e de plusieurs languages de programation fun main ( args : Array < String > ) { println ( \"Languages :\" ) showList ( languages ) println ( \"Odd Numbers to 10 :\" ) oddNumbersTo10 () }","title":"Les listes"},{"location":"tp0/#les-choix-et-les-conditions","text":"","title":"Les choix et les conditions"},{"location":"tp0/#if-else","text":"Toutes les structures de contr\u00f4le (\u00e0 l\u2019exception des boucles) sont des expressions , et pourront donc renvoyer une valeur. D\u2019ailleurs, en Kotlin, l\u2019op\u00e9rateur ternaire n\u2019existe plus : on pr\u00e9f\u00e9rera utiliser une condition if/else. var a = 10 var b = 12 val result = if ( a > b ){ a ++ a } else { b ++ b } print ( \"Result is : $result\" )","title":"if ... else"},{"location":"tp0/#selon","text":"La fameuse switch de Java, existe en kotlin mais avec une autre identit\u00e9. Oubliez switch et utilisez \u00e0 la place le mot-cl\u00e9 when . val number = 15 when ( number ){ 1 -> print ( \"Un\" ) 2 -> print ( \"Deux\" ) 3 -> print ( \"Trois\" ) else -> print ( \"Inconnu\" ) } Activit\u00e9 Cr\u00e9er une fonction qui prend en param\u00e8tres deux entiers et un op\u00e9rateur ( +, -, /,*, %) et renvoit le r\u00e9sultat de l'op\u00e9ration. Tester la fonction.","title":"selon ..."},{"location":"tp0/#les-classes","text":"En Kotlin, la visibilit\u00e9 par d\u00e9faut de n\u2019importe quel \u00e9l\u00e9ment de votre code (variables, fonctions, classes, etc.) est public . Il existe 4 principaux modificateurs de visibilit\u00e9 pour les membres (variables, fonctions, etc.) d\u2019une classe : private : Un membre d\u00e9clar\u00e9 comme private sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9. protected : Un membre d\u00e9clar\u00e9 comme protected sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9 ET dans ses sous-classes (via l\u2019h\u00e9ritage). internal : Un membre d\u00e9clar\u00e9 comme internal sera visible par tous ceux du m\u00eame module. Un module est un ensemble de fichiers compil\u00e9s ensemble (comme une librairie Gradle ou Maven, par exemple). public : Un membre d\u00e9clar\u00e9 comme public sera visible partout et par tout le monde. Pour pouvoir personnaliser un getter() ou un setter() en kotlin, il faut utiliser les mots cl\u00e9s get() et set() dans le corps de la classe. Exemple : class User ( email : String , var password : String , var age : Int ){ var email : String = email get () { println ( \"User is getting his email.\" ); return field } set ( value ) { println ( \"User is setting his email\" ); field = value } } Si nous souhaitons d\u00e9finir la propri\u00e9t\u00e9 password comme \u00e9tant priv\u00e9e, nous pouvons le faire en rajoutant le mot-cl\u00e9 private devant sa d\u00e9claration : class User ( var email : String , private var passwird : String , var age : Int )","title":"Les classes"},{"location":"tp0/#lheritage","text":"en Kotlin, toutes les classes et leurs m\u00e9thodes sont \"ferm\u00e9es\" par d\u00e9faut. Vous ne pourrez donc pas h\u00e9riter d\u2019une classe ou red\u00e9finir ses m\u00e9thodes sans l\u2019autorisation explicite. Ainsi, il faut indiquer explicitement, avec au mot-cl\u00e9 open , si une classe ou une m\u00e9thode peut \u00eatre \"ouverte\" \u00e0 l\u2019h\u00e9ritage. Les modificateurs d\u2019acc\u00e8s disponibles en Kotlin (\u00e0 ne pas confondre avec les modificateurs de visibilit\u00e9!) : final : Classe/M\u00e9thode/Propri\u00e9t\u00e9 ne pouvant pas \u00eatre red\u00e9finie. C\u2019est l\u2019\u00e9tat par d\u00e9faut de tous les \u00e9l\u00e9ments en Kotlin. open : Classe/M\u00e9thode/Propri\u00e9t\u00e9 pouvant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s doit \u00eatre indiqu\u00e9 explicitement. abstract : Classe/M\u00e9thode/Propri\u00e9t\u00e9 devant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s peut \u00eatre utilis\u00e9 uniquement dans des classes abstraites. Et bien entendu, le mot-cl\u00e9 override sera utilis\u00e9 pour red\u00e9finir un \u00e9l\u00e9ment d\u2019une classe parente (ou d\u2019une interface).","title":"L'heritage"},{"location":"tp0/#les-constructeurs-multiples","text":"Pour cr\u00e9er un second constructeur, il faut utiliser le mot cl\u00e9 constructor","title":"Les constructeurs multiples"},{"location":"tp0/#les-classes-de-donnees","text":"En Kotlin, nous pouvons d\u00e9finir une classe comme \u00e9tant destin\u00e9e \u00e0 contenir des mod\u00e8les de donn\u00e9es gr\u00e2ce au mot-cl\u00e9 data : data class User ( var email : String , var password : String , var isConnected : Boolean ) Gr\u00e2ce \u00e0 ce simple mot-cl\u00e9, le compilateur Kotlin impl\u00e9mentera pour nous les principales m\u00e9thodes utilis\u00e9es pour \"comparer\" et \"d\u00e9crire\" un objet contenant des donn\u00e9es comme les m\u00e9thodes toString() , hashCode() , equals() ou encore copy() .","title":"Les classes de donn\u00e9es"},{"location":"tp0/#function-types","text":"Il est possible d'avoir les variables de type fonction (quicontiennent une r\u00e9f\u00e9rence vers une fonction) et il est possible de passer une fonction comme param\u00e8tre d'une autre fonction. fun appl ( a : List < Int > , b : List < Int > , f : ( Int , Int ) -> Int ) : MutableList < Int > { var r = mutableListOf < Int > () val s = if ( a . size < b . size ) a . size else b . size for ( i in 0. . s - 1 ) r . add ( f ( a [ i ] , b [ i ] ) ) return r } appl() prend comme param\u00e8tres deux listes de Int et le troisi\u00e8me param\u00e8tre f: (Int,Int)-> Int est une fonction qui prend deux Int et retourne un Int. La fonction appl() construit une nouvelle liste obtenue en appliquant f aux couples correspondants de listes a et b. fun fu ( i : Int , j : Int ) : Int { return i * i + j * j } val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) //passer une fonction en param\u00e8tre val res = appl ( p , q , :: fu ) //le nom de fonction pr\u00e9c\u00e9d\u00e9 par :: ou par NomClasse:: si la fonction est d\u00e9finie dans une classe","title":"Function types"},{"location":"tp0/#fonctions-comme-parametres-lambda-expressions","text":"val res2 = appl ( p , q , { a , b -> a * b }) { a , b -> a * b } C'est une lambda expression qui d\u00e9signe une fonction sans nom avec les arguments a, b. Le compilateur d\u00e9duit le type de param\u00e8tres de la d\u00e9finition de appl(). Lambda expression avec le type de param\u00e8tres : { a : Int , b : Int -> val x = a - b x * x } La valeur de lambda expression est la derni\u00e8re valeur calcul\u00e9e dans le corps de la fonction. Si lambda expression est le dernier argument d'une fonction alors on peut la mettre en dehors des parenth\u00e8ses. val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) val res2 = appl ( p , q ) { a , b -> ( a - b ) * ( a - b ) }","title":"Fonctions comme param\u00e8tres, lambda-expressions"},{"location":"tp0/#travail-a-rendre","text":"Exercice Dans Android Studio, cr\u00e9ez l\u2019application TP01. Suivez les instructions donn\u00e9es dans ce TP pour cr\u00e9er une application \u00e0 ex\u00e9cuter sur un terminal. Hello Pour voir si votre application est correctement g\u00e9n\u00e9r\u00e9e dans AndroidStudio mettre dans la fonction main() l\u2019affichage de \"Hello\" et tester si votre programme s\u2019ex\u00e9cute correctement. classe Point D\u00e9finir la classe Point qui correspond \u00e0 un point sur le, plan avec les coordonn\u00e9es enti\u00e8res x et y. La classe Point sera d\u00e9clar\u00e9 comme data class. distance \u00c9crire la fonction distance qui prend comme argument deux points et calcule la distance entre eux. On suppose que la distance entre les point p et q est |p.x \u2212 q.x| + |p.y \u2212 q.y| (donc c\u2019est un Int).. classe Rectangle La classe Rectangle repr\u00e9sente un rectangle sur le plan dont les sommets ont les coordonn\u00e9es enti\u00e8res. Un tel rectangle est d\u00e9finie de fa\u00e7o,n unique par deux de ses sommets, le sommet p en bas \u00e0 gauche et q en haut \u00e0 droite. \u00c9crire la classe Rectangle avec un constructeur qui prend comme param\u00e8tres les points p et q. Les valeurs par d\u00e9faut pour les deux points sont respectivement (0, 0) et (1, 1). Red\u00e9finir la m\u00e9thode toString() de Rectangle pour qu\u2019elle retourne \"p=$p q=$q\". D\u00e9finir dans main() un Array compos\u00e9e de plusieurs rectangles. Pour d\u00e9finir les rectangles utilisez aussi les valeurs par d\u00e9faut (un rectangles avec p et q par d\u00e9faut, un rectangle avec la valeur p par d\u00e9faut et q d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, un rectangle avec la valeur q par d\u00e9faut et p d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, etc.) Dans la classe Rectangle ajouter la m\u00e9thode surface qui retourne la surface de rectangle. Dans main afficher la surface de chaque rectangle qui est dans le tableau d\u00e9fini pr\u00e9c\u00e9demment.","title":"Travail \u00e0 rendre"},{"location":"tp1/","text":"Cr\u00e9ation des interfaces graphiques et navigation Objectifs du TP Dans ce TP nous allons : D\u00e9couvrir Android Studio. D\u00e9couvrir les ressources, layouts et vues. Cr\u00e9er des interfaces graphiques simples. Naviguer entre les interfaces \u00e0 travers les intents. Exercice 1 Objectif Le but de cet exercice est de construire une interface utilisateur pr\u00e9sentant plusieurs composants graphiques Android (View). Cette interface permet de faire une authentification en demandant un couple (email, mot de passe). Apr\u00e8s appui sur le bouton Connecter, un message indique si le couple donn\u00e9 convient ou pas. Activit\u00e9-1 Indiquer les composants graphiques Android qui interviennent dans cette IHM. Activit\u00e9-2 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9. Comportement d\u2019un EditText EditText est une sous-classe de TextView qui h\u00e9rite donc de toutes les fonctions d'un TextView. De plus, cet outil dispose de nouvelles fonctionnalit\u00e9s permettant \u00e0 l'utilisateur de saisir ou de modifier le texte \u00e0 des fins diverses. Par cons\u00e9quent, il est n\u00e9cessaire de sp\u00e9cificier un type de donn\u00e9e qui peut accepter via l'attribut android:inputType. D\u00e9clarer un EditText dans votre classe MainActivity lateinit var txtEmail : EditText Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut editEmail en lui associant l'element EditText cr\u00e9\u00e9 dans le main.xml txtEmail = findViewById ( R . id . editTextEmail ) Ajouter le code suivant pour avoir la valeur de l'EditText: var email = txtEmail . text . toString () R\u00e9action aux interactions utilisateur Il existe 3 fa\u00e7ons pour manipuler le comportement d'un bouton sur Android: M\u00e9thode 1: Surcharge du Listener du bouton Cr\u00e9er un attribut dans votre activit\u00e9 de type Button : lateinit var btnLogin : Button Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut btnLogin en lui associant le bouton cr\u00e9\u00e9 dans le main.xml btnLogin = findViewById ( R . id . btnLogin ) Utiliser le code suivant pour d\u00e9finir le comportement du bouton btnLogin btnLogin . setOnClickListener { view -> // Do some work here } M\u00e8thode 2: D\u00e9finition d\u2019une m\u00e9thode propre au bouton ajouter l\u2019attribut onClick dans l'element Button dans le fichier xml : android:onClick=\"login\" Une erreur s'affiche indiquant que vous devez cr\u00e9er la m\u00e9thode login dans la classe MainActivity Cr\u00e8er la public void login ( View v ){ // Do some work here } M\u00e8thode 3: Impl\u00e9mentation de l\u2019interface OnClickListener Il est possible d\u2019utiliser l\u2019h\u00e9ritage pour surcharger la m\u00e9thode onClick, sans passer par l\u2019appel \u00e0 la m\u00e9thode setOnClickListener. Il suffit de suivre les \u00e9tapes suivantes : 1. Votre activity doit impl\u00e9menter l\u2019interface OnClickListener. Ceci est r\u00e9alis\u00e9 comme suit : class MainActivity : AppCompatActivity (), View . OnClickListener { ... } 1. Il vous demande alors d'implementer la m\u00e9thode onClick. Cliquer sur \" implement members \" et suiver les \u00e9tapes. Attention Cette m\u00e9thode sera commune \u00e0 tous les \u00e9l\u00e9ments cliquables, il faut donc distinguer le comportement selon l\u2018identifiant de l\u2018\u00e9l\u00e9ment cliqu\u00e9. Ajouter le code suivant : if ( view ? . id == R . id . btnLogin ){ // do some work } Activit\u00e9-3 Ecrire le code Kotlin qui, lorsque le bouton Connecter est actionn\u00e9 par l'utilisateur, une v\u00e9rification d'authentification est faite et un message affiche le r\u00e9sultat (bon couple login, mot de passe ou pas). Pour simplifier, on consid\u00e8re que le couple (gl4@insat.tn/insat2022) est correct. Info Pour afficher le message, utiliser un Toast . Comportement d\u2019une CheckBox La CheckBox est un bouton avec deux \u00e9tats checked (coch\u00e9s) et unchecked (non coch\u00e9s), c'est un composant de base et est tr\u00e8s souvent utilis\u00e9 dans les applications Android. Par d\u00e9faut, la CheckBox a un \u00e9tat unchecked, vous pouvez changer son \u00e9tat via la propri\u00e9t\u00e9 android:checked. <CheckBox android:id= \"@+id/someId\" android:checked= \"true\" ... /> Quelques propri\u00e9t\u00e9s importantes de CheckBox: Exercice 2 : Intent explicite Objectif Nous allons modifier le code cr\u00e9e dans l'exercice 1 de telle sorte que lorsqu'on clique sur le bouton, une nouvelle Activit\u00e9 affichant un message de Bienvenue s'ouvre. Nous allons donc utiliser un intent explicite Cr\u00e9er une Nouvelle Activity \"WelcomeActivity\" -------- Modifier le code dans la m\u00e9thode onClick pour cr\u00e9er un Intent val intent = Intent ( view . context , WelcomeActivity :: class . java ) Pour passer des param\u00e9tres \u00e0 la deuxi\u00e8me Activit\u00e9, on utilise la m\u00e9thode putExtra() qui prend en param\u00e8tres le nom du variable \u00e0 stoquer dans l'intent et sa valeur : intent . putExtra ( \"email\" , email ) Lancer la deuxi\u00e8me Activit\u00e9 startActivity ( intent ) Dans l'Activit\u00e9 WelcomeActivity ajouter le code suivant pour r\u00e9cup\u00e9rer la valeur de l'email. val email = intent . getStringExtra ( \"email\" ) Ajouter un TextView dans le ficher xml, lui attribuer un id et l'initialiser comme on a fait dans l'exercice 1. Afficher le message de Bienvenue. txtWelcome . text = \"Bienvenue $email\" Exercice 3 : Intent implicite Objectif Nous allons cr\u00e9er une application qui ouvre la galerie de photo pour choisir une image et l\u2019afficher Activit\u00e9-1 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9. Exercice 4 : Travail \u00e0 rendre Votre premier travail sera divis\u00e9 en 2 parties : En premier lieu, vous allez d\u00e9couvrir le material design, le c\u00e9l\u00e8bre langage visuel d\u00e9fini par Google. Commencer par consulter sa documentation officielle ici . Lire attentivement les diff\u00e9rentes recommandations et bonnes pratiques dict\u00e9es par Google pour la conception d\u2019interfaces graphiques. En deuxi\u00e8me lieu, vous allez appliquer ce patron et les notions vues dans ce TP sur une simple application de commande de pizza dans un restaurant. L'application aura une interface principale, o\u00f9 l'utilisateur doit introduire son nom, pr\u00e9nom et son adresse, choisir le type de pizza qu'il veut commander (Moyenne, Mini, Maxi) et les ingr\u00e9dients \u00e0 ajouter (Fromage, champignon, etc.). L'application doit lui permettre ensuite d'envoyer un SMS (ou un email) au vendeur, contenant un r\u00e9capitulatif de la commande. Ajouter ensuite une interface d'accueil (Splash Screen) qui s'affiche pendant 5 secondes puis redirige l'utilisateur \u00e0 l'interface principale.","title":"TP1: Cr\u00e9ation des interfaces graphiques et navigation"},{"location":"tp1/#creation-des-interfaces-graphiques-et-navigation","text":"","title":"Cr\u00e9ation des interfaces graphiques et navigation"},{"location":"tp1/#objectifs-du-tp","text":"Dans ce TP nous allons : D\u00e9couvrir Android Studio. D\u00e9couvrir les ressources, layouts et vues. Cr\u00e9er des interfaces graphiques simples. Naviguer entre les interfaces \u00e0 travers les intents.","title":"Objectifs du TP"},{"location":"tp1/#exercice-1","text":"","title":"Exercice 1"},{"location":"tp1/#objectif","text":"Le but de cet exercice est de construire une interface utilisateur pr\u00e9sentant plusieurs composants graphiques Android (View). Cette interface permet de faire une authentification en demandant un couple (email, mot de passe). Apr\u00e8s appui sur le bouton Connecter, un message indique si le couple donn\u00e9 convient ou pas. Activit\u00e9-1 Indiquer les composants graphiques Android qui interviennent dans cette IHM. Activit\u00e9-2 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.","title":"Objectif"},{"location":"tp1/#comportement-dun-edittext","text":"EditText est une sous-classe de TextView qui h\u00e9rite donc de toutes les fonctions d'un TextView. De plus, cet outil dispose de nouvelles fonctionnalit\u00e9s permettant \u00e0 l'utilisateur de saisir ou de modifier le texte \u00e0 des fins diverses. Par cons\u00e9quent, il est n\u00e9cessaire de sp\u00e9cificier un type de donn\u00e9e qui peut accepter via l'attribut android:inputType. D\u00e9clarer un EditText dans votre classe MainActivity lateinit var txtEmail : EditText Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut editEmail en lui associant l'element EditText cr\u00e9\u00e9 dans le main.xml txtEmail = findViewById ( R . id . editTextEmail ) Ajouter le code suivant pour avoir la valeur de l'EditText: var email = txtEmail . text . toString ()","title":"Comportement d\u2019un EditText"},{"location":"tp1/#reaction-aux-interactions-utilisateur","text":"Il existe 3 fa\u00e7ons pour manipuler le comportement d'un bouton sur Android:","title":"R\u00e9action aux interactions utilisateur"},{"location":"tp1/#methode-1-surcharge-du-listener-du-bouton","text":"Cr\u00e9er un attribut dans votre activit\u00e9 de type Button : lateinit var btnLogin : Button Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut btnLogin en lui associant le bouton cr\u00e9\u00e9 dans le main.xml btnLogin = findViewById ( R . id . btnLogin ) Utiliser le code suivant pour d\u00e9finir le comportement du bouton btnLogin btnLogin . setOnClickListener { view -> // Do some work here }","title":"M\u00e9thode 1: Surcharge du Listener du bouton"},{"location":"tp1/#methode-2-definition-dune-methode-propre-au-bouton","text":"ajouter l\u2019attribut onClick dans l'element Button dans le fichier xml : android:onClick=\"login\" Une erreur s'affiche indiquant que vous devez cr\u00e9er la m\u00e9thode login dans la classe MainActivity Cr\u00e8er la public void login ( View v ){ // Do some work here }","title":"M\u00e8thode 2: D\u00e9finition d\u2019une m\u00e9thode propre au bouton"},{"location":"tp1/#methode-3-implementation-de-linterface-onclicklistener","text":"Il est possible d\u2019utiliser l\u2019h\u00e9ritage pour surcharger la m\u00e9thode onClick, sans passer par l\u2019appel \u00e0 la m\u00e9thode setOnClickListener. Il suffit de suivre les \u00e9tapes suivantes : 1. Votre activity doit impl\u00e9menter l\u2019interface OnClickListener. Ceci est r\u00e9alis\u00e9 comme suit : class MainActivity : AppCompatActivity (), View . OnClickListener { ... } 1. Il vous demande alors d'implementer la m\u00e9thode onClick. Cliquer sur \" implement members \" et suiver les \u00e9tapes. Attention Cette m\u00e9thode sera commune \u00e0 tous les \u00e9l\u00e9ments cliquables, il faut donc distinguer le comportement selon l\u2018identifiant de l\u2018\u00e9l\u00e9ment cliqu\u00e9. Ajouter le code suivant : if ( view ? . id == R . id . btnLogin ){ // do some work } Activit\u00e9-3 Ecrire le code Kotlin qui, lorsque le bouton Connecter est actionn\u00e9 par l'utilisateur, une v\u00e9rification d'authentification est faite et un message affiche le r\u00e9sultat (bon couple login, mot de passe ou pas). Pour simplifier, on consid\u00e8re que le couple (gl4@insat.tn/insat2022) est correct. Info Pour afficher le message, utiliser un Toast .","title":"M\u00e8thode 3: Impl\u00e9mentation de l\u2019interface OnClickListener"},{"location":"tp1/#comportement-dune-checkbox","text":"La CheckBox est un bouton avec deux \u00e9tats checked (coch\u00e9s) et unchecked (non coch\u00e9s), c'est un composant de base et est tr\u00e8s souvent utilis\u00e9 dans les applications Android. Par d\u00e9faut, la CheckBox a un \u00e9tat unchecked, vous pouvez changer son \u00e9tat via la propri\u00e9t\u00e9 android:checked. <CheckBox android:id= \"@+id/someId\" android:checked= \"true\" ... /> Quelques propri\u00e9t\u00e9s importantes de CheckBox:","title":"Comportement d\u2019une CheckBox"},{"location":"tp1/#exercice-2-intent-explicite","text":"","title":"Exercice 2 : Intent explicite"},{"location":"tp1/#objectif_1","text":"Nous allons modifier le code cr\u00e9e dans l'exercice 1 de telle sorte que lorsqu'on clique sur le bouton, une nouvelle Activit\u00e9 affichant un message de Bienvenue s'ouvre. Nous allons donc utiliser un intent explicite Cr\u00e9er une Nouvelle Activity \"WelcomeActivity\" -------- Modifier le code dans la m\u00e9thode onClick pour cr\u00e9er un Intent val intent = Intent ( view . context , WelcomeActivity :: class . java ) Pour passer des param\u00e9tres \u00e0 la deuxi\u00e8me Activit\u00e9, on utilise la m\u00e9thode putExtra() qui prend en param\u00e8tres le nom du variable \u00e0 stoquer dans l'intent et sa valeur : intent . putExtra ( \"email\" , email ) Lancer la deuxi\u00e8me Activit\u00e9 startActivity ( intent ) Dans l'Activit\u00e9 WelcomeActivity ajouter le code suivant pour r\u00e9cup\u00e9rer la valeur de l'email. val email = intent . getStringExtra ( \"email\" ) Ajouter un TextView dans le ficher xml, lui attribuer un id et l'initialiser comme on a fait dans l'exercice 1. Afficher le message de Bienvenue. txtWelcome . text = \"Bienvenue $email\"","title":"Objectif"},{"location":"tp1/#exercice-3-intent-implicite","text":"","title":"Exercice 3 : Intent implicite"},{"location":"tp1/#objectif_2","text":"Nous allons cr\u00e9er une application qui ouvre la galerie de photo pour choisir une image et l\u2019afficher Activit\u00e9-1 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.","title":"Objectif"},{"location":"tp1/#exercice-4-travail-a-rendre","text":"Votre premier travail sera divis\u00e9 en 2 parties : En premier lieu, vous allez d\u00e9couvrir le material design, le c\u00e9l\u00e8bre langage visuel d\u00e9fini par Google. Commencer par consulter sa documentation officielle ici . Lire attentivement les diff\u00e9rentes recommandations et bonnes pratiques dict\u00e9es par Google pour la conception d\u2019interfaces graphiques. En deuxi\u00e8me lieu, vous allez appliquer ce patron et les notions vues dans ce TP sur une simple application de commande de pizza dans un restaurant. L'application aura une interface principale, o\u00f9 l'utilisateur doit introduire son nom, pr\u00e9nom et son adresse, choisir le type de pizza qu'il veut commander (Moyenne, Mini, Maxi) et les ingr\u00e9dients \u00e0 ajouter (Fromage, champignon, etc.). L'application doit lui permettre ensuite d'envoyer un SMS (ou un email) au vendeur, contenant un r\u00e9capitulatif de la commande. Ajouter ensuite une interface d'accueil (Splash Screen) qui s'affiche pendant 5 secondes puis redirige l'utilisateur \u00e0 l'interface principale.","title":"Exercice 4 : Travail \u00e0 rendre"},{"location":"tp2/","text":"","title":"TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : RecyclerView"},{"location":"tp3/","text":"","title":"TP3: Cr\u00e9ation des Fragments"},{"location":"tp4/","text":"","title":"TP4: Stockage de donn\u00e9es"},{"location":"tp5/","text":"","title":"TP5: Firebase"},{"location":"tp6/","text":"","title":"TP6: Connexion \u00e0 des services web REST"},{"location":"tp7/","text":"","title":"TP7: MVVM avec Android"}]}