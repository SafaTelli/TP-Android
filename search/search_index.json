{"config":{"indexing":"full","lang":["fr"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"TP Android - GL4 Ce cours comporte 6 s\u00e9ances de travaux pratiques: TP1: Cr\u00e9ation des interfaces graphiques et navigation TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : RecyclerView TP3: Cr\u00e9ation des Fragments TP4: Base de donn\u00e9es interne / Firebase TP5: Connexion \u00e0 des services web REST TP6: MVVM avec Android","title":"Introduction"},{"location":"#tp-android-gl4","text":"Ce cours comporte 6 s\u00e9ances de travaux pratiques: TP1: Cr\u00e9ation des interfaces graphiques et navigation TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : RecyclerView TP3: Cr\u00e9ation des Fragments TP4: Base de donn\u00e9es interne / Firebase TP5: Connexion \u00e0 des services web REST TP6: MVVM avec Android","title":"TP Android - GL4"},{"location":"tp0/","text":"Initiation au langage Kotlin Objectifs du TP Dans ce TP nous allons nous familiariser avec le langage kotlin Langage Kotlin Kotlin a \u00e9t\u00e9 d\u00e9velopp\u00e9 par JetBrains dans l\u2019objectif de pallier les limitations qu\u2019imposait Java dans le d\u00e9veloppement de ses diff\u00e9rents produits. Kotlin est un langage de programmation \"statiquement typ\u00e9\" supportant n\u00e9anmoins \"l\u2019inf\u00e9rence de type\" gr\u00e2ce \u00e0 son compilateur. Kotlin supporte la \"programmation orient\u00e9e objet\" et la \"programmation fonctionnelle\". Kotlin est open source, supporte la plupart des IDE et fonctionne sur la majorit\u00e9 des plateformes Java actuelles (o\u00f9 le bytecode JVM est accept\u00e9) En 2017, Google a annonc\u00e9 lors de sa conf\u00e9rence Google I/O, que kotlin est d\u00e9sormais son langage pr\u00e9f\u00e9r\u00e9 pour les d\u00e9veloppeurs d'applications Android. Premi\u00e8re application kotlin Lancer AndroidStudio File -> New -> New Project S\u00e9lectionner \"No Activity\" (pour une application sur le terminal) Choisir le nom du projet (ici Hello) Le nom de package (ici com.gl4.tp) Le r\u00e9pertoire du projet Langage (Kotlin) File -> New ->Kotlin Class/File pour ajouter le fichier source Choisir le nom du fichier (Hello.kt) Le programme doit contenir fonction main suivante : fun main ( argv : Array < String > )){ print ( \"Hello\" ) } 11. Ex\u00e9cuter le programme en choisisant : Run 'HelloKt' Voici le r\u00e9sultat : Les variables La mention du type d'une variable n'est pas obligatoire en Kotlin. Le compilateur de Kotlin poss\u00e8de une fonctionnalit\u00e9 appel\u00e9e \"l\u2019inf\u00e9rence de type\", ou \"type inference\", en anglais. Pour que cela soit plus parlant, comprenez par \"inf\u00e9rence\" la notion de \"d\u00e9duction\" ! . Kotlin se voulant \u00eatre un langage tr\u00e8s intelligent, ses d\u00e9veloppeurs ont souhait\u00e9 lui offrir les avantages de lisibilit\u00e9 des langages \"dynamiquement typ\u00e9s\", mais sans leurs inconv\u00e9nients. En effet, pour Kotlin, ce sera au moment de la compilation (et non au moment de l\u2019ex\u00e9cution) que les types de vos variables seront automatiquement d\u00e9duit. val name : String = \"Mohamed\" val age : Int = 27 val isDeveloper : Boolean = true Equivaut \u00e0 : val name = \"Mohamed\" val age = 27 val isDeveloper = true Les types nullables Kotlin est un langage dit \"s\u00fbr\". Derri\u00e8re cet adjectif r\u00e9confortant se cache en r\u00e9alit\u00e9 un ensemble de fonctionnalit\u00e9s am\u00e9liorant la s\u00fbret\u00e9 du langage, dont la fameuse \" Null Safety \". Exemple concret : Copier le code suivant dans fonction main() cr\u00e9e au d\u00e9part : var message : String ? = \"My message can possibly be null !\" message . upperCase () Comme vous le voyez sur l\u2019exemple ci-dessus, nous avons d\u00e9clar\u00e9 la variable message comme pouvant \"possiblement\" contenir une valeur nulle. Puis, lorsque nous souhaitons ensuite acc\u00e9der \u00e0 sa m\u00e9thode upperCase() , le compilateur Kotlin nous souligne en rouge le point pr\u00e9c\u00e9dant cette m\u00e9thode pour nous dire que cela est impossible, car la variable peut \u00eatre possiblement nulle. Pour g\u00e9rer une variable possiblement nulle il faut utiliser le point d\u2019interrogation afin d\u2019appeler une de ses m\u00e9thodes de mani\u00e8re s\u00e9curis\u00e9e. D\u00e8s lors, si jamais la variable est \u00e9gale \u00e0 nulle, la m\u00e9thode ne sera tout simplement pas appel\u00e9e ! En revanche, si la variable contient bien une valeur, alors la m\u00e9thode sera appel\u00e9e et ex\u00e9cut\u00e9e. var message : String ? = \"My message can possibly be null !\" message . upperCase () L' op\u00e9rateur !!. l'op\u00e9rateur d'assertion non nul (!!) convertit toute valeur en un type non nul et l\u00e8ve une exception si la valeur est nulle. Vous pouvez \u00e9crire x!!, et cela renverra une valeur non nulle de x (par exemple, une cha\u00eene) ou lancera un NullPointerException si x est null : val ville = personnel [ i ]!! . adresse !! . city //si personnel[i] ou adresse est \u00e9gale \u00e0 null alors NullPointerException, par contre city peut \u00eatre null L' op\u00e9rateur elvis ?: var s = savedInstanceState ? . getInt ( \"key\" ) ? : 0 Si la valeur de savedInstanceState?.getInt(\"key\") est un Int alors s prendra cette valeur, si la valeur de cette expression est null alors s prendra la valeur 0 Le mot cl\u00e9 lateinit Imaginez que vous ne souhaitiez pas initialiser votre variable imm\u00e9diatement apr\u00e8s sa d\u00e9claration, mais le faire un peu plus tard dans votre code (quand par exemple une page ou un \u00e9cran a termin\u00e9 de charger). Vous allez tout simplement utiliser le mot-cl\u00e9 lateinit (pour \"Late-Initialized\") permettant d\u2019indiquer \u00e0 Kotlin que vous \u00eates s\u00fbr et certain d\u2019initialiser la variable en question, un peu plus tard dans votre code : private lateinit var submitButton : Button Le symbole $ Kotlin nous permet de manipuler un peu plus simplement les variables de type String . Nous allons pouvoir, par exemple, utiliser le symbole $ afin de faire r\u00e9f\u00e9rence \u00e0 une variable locale directement \u00e0 l\u2019int\u00e9rieur d\u2019un autre String : val name = \"Mohamed\" print ( \"Hello $name\" ) Activit\u00e9 Copier le code suivant et le corriger : val hello = \"Hello\" hello = \"Hello world!\" println ( hello ) var toto : Int = \"Toto\" println ( toto ) var message : String ? = \"I\u2019m learning Kotlin!\" message = null println ( message . toString ()) Les fonctions Activit\u00e9 Ecrire une fonction qui prend 2 valeurs en param\u00e8tres et retourne leurs somme. Corriger cette fonction: fun sayMyName () { println ( \" $name \" ) } Simplifier cette fonction: fun sayHello (): String { return \"Hello\" } Les boucles Les listes En Kotlin, vous aurez la possibilit\u00e9 de cr\u00e9er tr\u00e8s facilement des listes de valeurs afin de lier diff\u00e9rentes donn\u00e9es entre elles. Nous allons ainsi pouvoir appeler les m\u00e9thodes g\u00e9n\u00e9riques suivantes : listOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et immuable. mutableListOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et muable. setOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et immuable. mutableSetOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et muable. // listOf val listOfNames = listOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => ERROR ! List is immutable // mutableListOf val listOfNames = mutableListOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => SUCCESS ! // setOf val setOfNames = setOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => ERROR ! Set is immutable // mutableSetOf val setOfNames = mutableSetOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => SUCCESS ! Info Sachez \u00e9galement qu\u2019il existe d\u2019autres m\u00e9thodes comme arrayOf pour cr\u00e9er un tableau de valeurs, et m\u00eame mapOf pour cr\u00e9er un dictionnaire de valeurs. Activit\u00e9 fun showList ( list : List < String > ){ // Compl\u00e9tez la fonction pour afficher les \u00e9l\u00e9ments de la liste } fun oddNumbersTo10 (){ // Compl\u00e9tez la fonction pour afficher les nombres impairs jusqu'\u00e0 10 } private val languages = // Cr\u00e9ez une liste ordonn\u00e9e de plusieurs languages de programation fun main ( args : Array < String > ) { println ( \"Languages :\" ) showList ( languages ) println ( \"Odd Numbers to 10 :\" ) oddNumbersTo10 () } Les choix et les conditions if ... else Toutes les structures de contr\u00f4le (\u00e0 l\u2019exception des boucles) sont des expressions , et pourront donc renvoyer une valeur. D\u2019ailleurs, en Kotlin, l\u2019op\u00e9rateur ternaire n\u2019existe plus : on pr\u00e9f\u00e9rera utiliser une condition if/else. var a = 10 var b = 12 val result = if ( a > b ){ a ++ a } else { b ++ b } print ( \"Result is : $result\" ) selon ... La fameuse switch de Java, existe en kotlin mais avec une autre identit\u00e9. Oubliez switch et utilisez \u00e0 la place le mot-cl\u00e9 when . val number = 15 when ( number ){ 1 -> print ( \"Un\" ) 2 -> print ( \"Deux\" ) 3 -> print ( \"Trois\" ) else -> print ( \"Inconnu\" ) } Activit\u00e9 Cr\u00e9er une fonction qui prend en param\u00e8tres deux entiers et un op\u00e9rateur ( +, -, /,*, %) et renvoit le r\u00e9sultat de l'op\u00e9ration. Tester la fonction. Les classes En Kotlin, la visibilit\u00e9 par d\u00e9faut de n\u2019importe quel \u00e9l\u00e9ment de votre code (variables, fonctions, classes, etc.) est public . Il existe 4 principaux modificateurs de visibilit\u00e9 pour les membres (variables, fonctions, etc.) d\u2019une classe : private : Un membre d\u00e9clar\u00e9 comme private sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9. protected : Un membre d\u00e9clar\u00e9 comme protected sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9 ET dans ses sous-classes (via l\u2019h\u00e9ritage). internal : Un membre d\u00e9clar\u00e9 comme internal sera visible par tous ceux du m\u00eame module. Un module est un ensemble de fichiers compil\u00e9s ensemble (comme une librairie Gradle ou Maven, par exemple). public : Un membre d\u00e9clar\u00e9 comme public sera visible partout et par tout le monde. Pour pouvoir personnaliser un getter() ou un setter() en kotlin, il faut utiliser les mots cl\u00e9s get() et set() dans le corps de la classe. Exemple : class User ( email : String , var password : String , var age : Int ){ var email : String = email get () { println ( \"User is getting his email.\" ); return field } set ( value ) { println ( \"User is setting his email\" ); field = value } } Si nous souhaitons d\u00e9finir la propri\u00e9t\u00e9 password comme \u00e9tant priv\u00e9e, nous pouvons le faire en rajoutant le mot-cl\u00e9 private devant sa d\u00e9claration : class User ( var email : String , private var passwird : String , var age : Int ) L'heritage en Kotlin, toutes les classes et leurs m\u00e9thodes sont \"ferm\u00e9es\" par d\u00e9faut. Vous ne pourrez donc pas h\u00e9riter d\u2019une classe ou red\u00e9finir ses m\u00e9thodes sans l\u2019autorisation explicite. Ainsi, il faut indiquer explicitement, avec au mot-cl\u00e9 open , si une classe ou une m\u00e9thode peut \u00eatre \"ouverte\" \u00e0 l\u2019h\u00e9ritage. Les modificateurs d\u2019acc\u00e8s disponibles en Kotlin (\u00e0 ne pas confondre avec les modificateurs de visibilit\u00e9!) : final : Classe/M\u00e9thode/Propri\u00e9t\u00e9 ne pouvant pas \u00eatre red\u00e9finie. C\u2019est l\u2019\u00e9tat par d\u00e9faut de tous les \u00e9l\u00e9ments en Kotlin. open : Classe/M\u00e9thode/Propri\u00e9t\u00e9 pouvant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s doit \u00eatre indiqu\u00e9 explicitement. abstract : Classe/M\u00e9thode/Propri\u00e9t\u00e9 devant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s peut \u00eatre utilis\u00e9 uniquement dans des classes abstraites. Et bien entendu, le mot-cl\u00e9 override sera utilis\u00e9 pour red\u00e9finir un \u00e9l\u00e9ment d\u2019une classe parente (ou d\u2019une interface). Les constructeurs multiples Pour cr\u00e9er un second constructeur, il faut utiliser le mot cl\u00e9 constructor Les classes de donn\u00e9es En Kotlin, nous pouvons d\u00e9finir une classe comme \u00e9tant destin\u00e9e \u00e0 contenir des mod\u00e8les de donn\u00e9es gr\u00e2ce au mot-cl\u00e9 data : data class User ( var email : String , var password : String , var isConnected : Boolean ) Gr\u00e2ce \u00e0 ce simple mot-cl\u00e9, le compilateur Kotlin impl\u00e9mentera pour nous les principales m\u00e9thodes utilis\u00e9es pour \"comparer\" et \"d\u00e9crire\" un objet contenant des donn\u00e9es comme les m\u00e9thodes toString() , hashCode() , equals() ou encore copy() . Function types Il est possible d'avoir les variables de type fonction (quicontiennent une r\u00e9f\u00e9rence vers une fonction) et il est possible de passer une fonction comme param\u00e8tre d'une autre fonction. fun appl ( a : List < Int > , b : List < Int > , f : ( Int , Int ) -> Int ) : MutableList < Int > { var r = mutableListOf < Int > () val s = if ( a . size < b . size ) a . size else b . size for ( i in 0. . s - 1 ) r . add ( f ( a [ i ] , b [ i ] ) ) return r } appl() prend comme param\u00e8tres deux listes de Int et le troisi\u00e8me param\u00e8tre f: (Int,Int)-> Int est une fonction qui prend deux Int et retourne un Int. La fonction appl() construit une nouvelle liste obtenue en appliquant f aux couples correspondants de listes a et b. fun fu ( i : Int , j : Int ) : Int { return i * i + j * j } val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) //passer une fonction en param\u00e8tre val res = appl ( p , q , :: fu ) //le nom de fonction pr\u00e9c\u00e9d\u00e9 par :: ou par NomClasse:: si la fonction est d\u00e9finie dans une classe Fonctions comme param\u00e8tres, lambda-expressions val res2 = appl ( p , q , { a , b -> a * b }) { a , b -> a * b } C'est une lambda expression qui d\u00e9signe une fonction sans nom avec les arguments a, b. Le compilateur d\u00e9duit le type de param\u00e8tres de la d\u00e9finition de appl(). Lambda expression avec le type de param\u00e8tres : { a : Int , b : Int -> val x = a - b x * x } La valeur de lambda expression est la derni\u00e8re valeur calcul\u00e9e dans le corps de la fonction. Si lambda expression est le dernier argument d'une fonction alors on peut la mettre en dehors des parenth\u00e8ses. val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) val res2 = appl ( p , q ) { a , b -> ( a - b ) * ( a - b ) } Travail \u00e0 rendre Exercice Dans Android Studio, cr\u00e9ez l\u2019application TP01. Suivez les instructions donn\u00e9es dans ce TP pour cr\u00e9er une application \u00e0 ex\u00e9cuter sur un terminal. Hello Pour voir si votre application est correctement g\u00e9n\u00e9r\u00e9e dans AndroidStudio mettre dans la fonction main() l\u2019affichage de \"Hello\" et tester si votre programme s\u2019ex\u00e9cute correctement. classe Point D\u00e9finir la classe Point qui correspond \u00e0 un point sur le, plan avec les coordonn\u00e9es enti\u00e8res x et y. La classe Point sera d\u00e9clar\u00e9 comme data class. distance \u00c9crire la fonction distance qui prend comme argument deux points et calcule la distance entre eux. On suppose que la distance entre les point p et q est |p.x \u2212 q.x| + |p.y \u2212 q.y| (donc c\u2019est un Int).. classe Rectangle La classe Rectangle repr\u00e9sente un rectangle sur le plan dont les sommets ont les coordonn\u00e9es enti\u00e8res. Un tel rectangle est d\u00e9finie de fa\u00e7o,n unique par deux de ses sommets, le sommet p en bas \u00e0 gauche et q en haut \u00e0 droite. \u00c9crire la classe Rectangle avec un constructeur qui prend comme param\u00e8tres les points p et q. Les valeurs par d\u00e9faut pour les deux points sont respectivement (0, 0) et (1, 1). Red\u00e9finir la m\u00e9thode toString() de Rectangle pour qu\u2019elle retourne \"p=$p q=$q\". D\u00e9finir dans main() un Array compos\u00e9e de plusieurs rectangles. Pour d\u00e9finir les rectangles utilisez aussi les valeurs par d\u00e9faut (un rectangles avec p et q par d\u00e9faut, un rectangle avec la valeur p par d\u00e9faut et q d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, un rectangle avec la valeur q par d\u00e9faut et p d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, etc.) Dans la classe Rectangle ajouter la m\u00e9thode surface qui retourne la surface de rectangle. Dans main afficher la surface de chaque rectangle qui est dans le tableau d\u00e9fini pr\u00e9c\u00e9demment.","title":"TP0: Intitiation au langage Kotlin"},{"location":"tp0/#initiation-au-langage-kotlin","text":"","title":"Initiation au langage Kotlin"},{"location":"tp0/#objectifs-du-tp","text":"Dans ce TP nous allons nous familiariser avec le langage kotlin","title":"Objectifs du TP"},{"location":"tp0/#langage-kotlin","text":"Kotlin a \u00e9t\u00e9 d\u00e9velopp\u00e9 par JetBrains dans l\u2019objectif de pallier les limitations qu\u2019imposait Java dans le d\u00e9veloppement de ses diff\u00e9rents produits. Kotlin est un langage de programmation \"statiquement typ\u00e9\" supportant n\u00e9anmoins \"l\u2019inf\u00e9rence de type\" gr\u00e2ce \u00e0 son compilateur. Kotlin supporte la \"programmation orient\u00e9e objet\" et la \"programmation fonctionnelle\". Kotlin est open source, supporte la plupart des IDE et fonctionne sur la majorit\u00e9 des plateformes Java actuelles (o\u00f9 le bytecode JVM est accept\u00e9) En 2017, Google a annonc\u00e9 lors de sa conf\u00e9rence Google I/O, que kotlin est d\u00e9sormais son langage pr\u00e9f\u00e9r\u00e9 pour les d\u00e9veloppeurs d'applications Android.","title":"Langage Kotlin"},{"location":"tp0/#premiere-application-kotlin","text":"Lancer AndroidStudio File -> New -> New Project S\u00e9lectionner \"No Activity\" (pour une application sur le terminal) Choisir le nom du projet (ici Hello) Le nom de package (ici com.gl4.tp) Le r\u00e9pertoire du projet Langage (Kotlin) File -> New ->Kotlin Class/File pour ajouter le fichier source Choisir le nom du fichier (Hello.kt) Le programme doit contenir fonction main suivante : fun main ( argv : Array < String > )){ print ( \"Hello\" ) } 11. Ex\u00e9cuter le programme en choisisant : Run 'HelloKt' Voici le r\u00e9sultat :","title":"Premi\u00e8re application kotlin"},{"location":"tp0/#les-variables","text":"La mention du type d'une variable n'est pas obligatoire en Kotlin. Le compilateur de Kotlin poss\u00e8de une fonctionnalit\u00e9 appel\u00e9e \"l\u2019inf\u00e9rence de type\", ou \"type inference\", en anglais. Pour que cela soit plus parlant, comprenez par \"inf\u00e9rence\" la notion de \"d\u00e9duction\" ! . Kotlin se voulant \u00eatre un langage tr\u00e8s intelligent, ses d\u00e9veloppeurs ont souhait\u00e9 lui offrir les avantages de lisibilit\u00e9 des langages \"dynamiquement typ\u00e9s\", mais sans leurs inconv\u00e9nients. En effet, pour Kotlin, ce sera au moment de la compilation (et non au moment de l\u2019ex\u00e9cution) que les types de vos variables seront automatiquement d\u00e9duit. val name : String = \"Mohamed\" val age : Int = 27 val isDeveloper : Boolean = true Equivaut \u00e0 : val name = \"Mohamed\" val age = 27 val isDeveloper = true","title":"Les variables"},{"location":"tp0/#les-types-nullables","text":"Kotlin est un langage dit \"s\u00fbr\". Derri\u00e8re cet adjectif r\u00e9confortant se cache en r\u00e9alit\u00e9 un ensemble de fonctionnalit\u00e9s am\u00e9liorant la s\u00fbret\u00e9 du langage, dont la fameuse \" Null Safety \". Exemple concret : Copier le code suivant dans fonction main() cr\u00e9e au d\u00e9part : var message : String ? = \"My message can possibly be null !\" message . upperCase () Comme vous le voyez sur l\u2019exemple ci-dessus, nous avons d\u00e9clar\u00e9 la variable message comme pouvant \"possiblement\" contenir une valeur nulle. Puis, lorsque nous souhaitons ensuite acc\u00e9der \u00e0 sa m\u00e9thode upperCase() , le compilateur Kotlin nous souligne en rouge le point pr\u00e9c\u00e9dant cette m\u00e9thode pour nous dire que cela est impossible, car la variable peut \u00eatre possiblement nulle. Pour g\u00e9rer une variable possiblement nulle il faut utiliser le point d\u2019interrogation afin d\u2019appeler une de ses m\u00e9thodes de mani\u00e8re s\u00e9curis\u00e9e. D\u00e8s lors, si jamais la variable est \u00e9gale \u00e0 nulle, la m\u00e9thode ne sera tout simplement pas appel\u00e9e ! En revanche, si la variable contient bien une valeur, alors la m\u00e9thode sera appel\u00e9e et ex\u00e9cut\u00e9e. var message : String ? = \"My message can possibly be null !\" message . upperCase ()","title":"Les types nullables"},{"location":"tp0/#l-operateur","text":"l'op\u00e9rateur d'assertion non nul (!!) convertit toute valeur en un type non nul et l\u00e8ve une exception si la valeur est nulle. Vous pouvez \u00e9crire x!!, et cela renverra une valeur non nulle de x (par exemple, une cha\u00eene) ou lancera un NullPointerException si x est null : val ville = personnel [ i ]!! . adresse !! . city //si personnel[i] ou adresse est \u00e9gale \u00e0 null alors NullPointerException, par contre city peut \u00eatre null","title":"L' op\u00e9rateur !!."},{"location":"tp0/#l-operateur-elvis","text":"var s = savedInstanceState ? . getInt ( \"key\" ) ? : 0 Si la valeur de savedInstanceState?.getInt(\"key\") est un Int alors s prendra cette valeur, si la valeur de cette expression est null alors s prendra la valeur 0","title":"L' op\u00e9rateur elvis ?:"},{"location":"tp0/#le-mot-cle-lateinit","text":"Imaginez que vous ne souhaitiez pas initialiser votre variable imm\u00e9diatement apr\u00e8s sa d\u00e9claration, mais le faire un peu plus tard dans votre code (quand par exemple une page ou un \u00e9cran a termin\u00e9 de charger). Vous allez tout simplement utiliser le mot-cl\u00e9 lateinit (pour \"Late-Initialized\") permettant d\u2019indiquer \u00e0 Kotlin que vous \u00eates s\u00fbr et certain d\u2019initialiser la variable en question, un peu plus tard dans votre code : private lateinit var submitButton : Button","title":"Le mot cl\u00e9 lateinit"},{"location":"tp0/#le-symbole","text":"Kotlin nous permet de manipuler un peu plus simplement les variables de type String . Nous allons pouvoir, par exemple, utiliser le symbole $ afin de faire r\u00e9f\u00e9rence \u00e0 une variable locale directement \u00e0 l\u2019int\u00e9rieur d\u2019un autre String : val name = \"Mohamed\" print ( \"Hello $name\" ) Activit\u00e9 Copier le code suivant et le corriger : val hello = \"Hello\" hello = \"Hello world!\" println ( hello ) var toto : Int = \"Toto\" println ( toto ) var message : String ? = \"I\u2019m learning Kotlin!\" message = null println ( message . toString ())","title":"Le symbole $"},{"location":"tp0/#les-fonctions","text":"Activit\u00e9 Ecrire une fonction qui prend 2 valeurs en param\u00e8tres et retourne leurs somme. Corriger cette fonction: fun sayMyName () { println ( \" $name \" ) } Simplifier cette fonction: fun sayHello (): String { return \"Hello\" }","title":"Les fonctions"},{"location":"tp0/#les-boucles","text":"","title":"Les boucles"},{"location":"tp0/#les-listes","text":"En Kotlin, vous aurez la possibilit\u00e9 de cr\u00e9er tr\u00e8s facilement des listes de valeurs afin de lier diff\u00e9rentes donn\u00e9es entre elles. Nous allons ainsi pouvoir appeler les m\u00e9thodes g\u00e9n\u00e9riques suivantes : listOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et immuable. mutableListOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments ordonn\u00e9e et muable. setOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et immuable. mutableSetOf : Permet de cr\u00e9er une liste d\u2019\u00e9l\u00e9ments d\u00e9sordonn\u00e9e et muable. // listOf val listOfNames = listOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => ERROR ! List is immutable // mutableListOf val listOfNames = mutableListOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames [ 0 ] // => Jake Wharton listOfNames [ 0 ] = \"Mathieu Nebra\" // => SUCCESS ! // setOf val setOfNames = setOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => ERROR ! Set is immutable // mutableSetOf val setOfNames = mutableSetOf ( \"Jake Wharton\" , \"Joe Birch\" , \"Robert Martin\" ) listOfNames . first () // => Jake Wharton listOfNames . add ( \"Mathieu Nebra\" ) // => SUCCESS ! Info Sachez \u00e9galement qu\u2019il existe d\u2019autres m\u00e9thodes comme arrayOf pour cr\u00e9er un tableau de valeurs, et m\u00eame mapOf pour cr\u00e9er un dictionnaire de valeurs. Activit\u00e9 fun showList ( list : List < String > ){ // Compl\u00e9tez la fonction pour afficher les \u00e9l\u00e9ments de la liste } fun oddNumbersTo10 (){ // Compl\u00e9tez la fonction pour afficher les nombres impairs jusqu'\u00e0 10 } private val languages = // Cr\u00e9ez une liste ordonn\u00e9e de plusieurs languages de programation fun main ( args : Array < String > ) { println ( \"Languages :\" ) showList ( languages ) println ( \"Odd Numbers to 10 :\" ) oddNumbersTo10 () }","title":"Les listes"},{"location":"tp0/#les-choix-et-les-conditions","text":"","title":"Les choix et les conditions"},{"location":"tp0/#if-else","text":"Toutes les structures de contr\u00f4le (\u00e0 l\u2019exception des boucles) sont des expressions , et pourront donc renvoyer une valeur. D\u2019ailleurs, en Kotlin, l\u2019op\u00e9rateur ternaire n\u2019existe plus : on pr\u00e9f\u00e9rera utiliser une condition if/else. var a = 10 var b = 12 val result = if ( a > b ){ a ++ a } else { b ++ b } print ( \"Result is : $result\" )","title":"if ... else"},{"location":"tp0/#selon","text":"La fameuse switch de Java, existe en kotlin mais avec une autre identit\u00e9. Oubliez switch et utilisez \u00e0 la place le mot-cl\u00e9 when . val number = 15 when ( number ){ 1 -> print ( \"Un\" ) 2 -> print ( \"Deux\" ) 3 -> print ( \"Trois\" ) else -> print ( \"Inconnu\" ) } Activit\u00e9 Cr\u00e9er une fonction qui prend en param\u00e8tres deux entiers et un op\u00e9rateur ( +, -, /,*, %) et renvoit le r\u00e9sultat de l'op\u00e9ration. Tester la fonction.","title":"selon ..."},{"location":"tp0/#les-classes","text":"En Kotlin, la visibilit\u00e9 par d\u00e9faut de n\u2019importe quel \u00e9l\u00e9ment de votre code (variables, fonctions, classes, etc.) est public . Il existe 4 principaux modificateurs de visibilit\u00e9 pour les membres (variables, fonctions, etc.) d\u2019une classe : private : Un membre d\u00e9clar\u00e9 comme private sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9. protected : Un membre d\u00e9clar\u00e9 comme protected sera visible uniquement dans la classe o\u00f9 il est d\u00e9clar\u00e9 ET dans ses sous-classes (via l\u2019h\u00e9ritage). internal : Un membre d\u00e9clar\u00e9 comme internal sera visible par tous ceux du m\u00eame module. Un module est un ensemble de fichiers compil\u00e9s ensemble (comme une librairie Gradle ou Maven, par exemple). public : Un membre d\u00e9clar\u00e9 comme public sera visible partout et par tout le monde. Pour pouvoir personnaliser un getter() ou un setter() en kotlin, il faut utiliser les mots cl\u00e9s get() et set() dans le corps de la classe. Exemple : class User ( email : String , var password : String , var age : Int ){ var email : String = email get () { println ( \"User is getting his email.\" ); return field } set ( value ) { println ( \"User is setting his email\" ); field = value } } Si nous souhaitons d\u00e9finir la propri\u00e9t\u00e9 password comme \u00e9tant priv\u00e9e, nous pouvons le faire en rajoutant le mot-cl\u00e9 private devant sa d\u00e9claration : class User ( var email : String , private var passwird : String , var age : Int )","title":"Les classes"},{"location":"tp0/#lheritage","text":"en Kotlin, toutes les classes et leurs m\u00e9thodes sont \"ferm\u00e9es\" par d\u00e9faut. Vous ne pourrez donc pas h\u00e9riter d\u2019une classe ou red\u00e9finir ses m\u00e9thodes sans l\u2019autorisation explicite. Ainsi, il faut indiquer explicitement, avec au mot-cl\u00e9 open , si une classe ou une m\u00e9thode peut \u00eatre \"ouverte\" \u00e0 l\u2019h\u00e9ritage. Les modificateurs d\u2019acc\u00e8s disponibles en Kotlin (\u00e0 ne pas confondre avec les modificateurs de visibilit\u00e9!) : final : Classe/M\u00e9thode/Propri\u00e9t\u00e9 ne pouvant pas \u00eatre red\u00e9finie. C\u2019est l\u2019\u00e9tat par d\u00e9faut de tous les \u00e9l\u00e9ments en Kotlin. open : Classe/M\u00e9thode/Propri\u00e9t\u00e9 pouvant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s doit \u00eatre indiqu\u00e9 explicitement. abstract : Classe/M\u00e9thode/Propri\u00e9t\u00e9 devant \u00eatre red\u00e9finie. Ce modificateur d\u2019acc\u00e8s peut \u00eatre utilis\u00e9 uniquement dans des classes abstraites. Et bien entendu, le mot-cl\u00e9 override sera utilis\u00e9 pour red\u00e9finir un \u00e9l\u00e9ment d\u2019une classe parente (ou d\u2019une interface).","title":"L'heritage"},{"location":"tp0/#les-constructeurs-multiples","text":"Pour cr\u00e9er un second constructeur, il faut utiliser le mot cl\u00e9 constructor","title":"Les constructeurs multiples"},{"location":"tp0/#les-classes-de-donnees","text":"En Kotlin, nous pouvons d\u00e9finir une classe comme \u00e9tant destin\u00e9e \u00e0 contenir des mod\u00e8les de donn\u00e9es gr\u00e2ce au mot-cl\u00e9 data : data class User ( var email : String , var password : String , var isConnected : Boolean ) Gr\u00e2ce \u00e0 ce simple mot-cl\u00e9, le compilateur Kotlin impl\u00e9mentera pour nous les principales m\u00e9thodes utilis\u00e9es pour \"comparer\" et \"d\u00e9crire\" un objet contenant des donn\u00e9es comme les m\u00e9thodes toString() , hashCode() , equals() ou encore copy() .","title":"Les classes de donn\u00e9es"},{"location":"tp0/#function-types","text":"Il est possible d'avoir les variables de type fonction (quicontiennent une r\u00e9f\u00e9rence vers une fonction) et il est possible de passer une fonction comme param\u00e8tre d'une autre fonction. fun appl ( a : List < Int > , b : List < Int > , f : ( Int , Int ) -> Int ) : MutableList < Int > { var r = mutableListOf < Int > () val s = if ( a . size < b . size ) a . size else b . size for ( i in 0. . s - 1 ) r . add ( f ( a [ i ] , b [ i ] ) ) return r } appl() prend comme param\u00e8tres deux listes de Int et le troisi\u00e8me param\u00e8tre f: (Int,Int)-> Int est une fonction qui prend deux Int et retourne un Int. La fonction appl() construit une nouvelle liste obtenue en appliquant f aux couples correspondants de listes a et b. fun fu ( i : Int , j : Int ) : Int { return i * i + j * j } val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) //passer une fonction en param\u00e8tre val res = appl ( p , q , :: fu ) //le nom de fonction pr\u00e9c\u00e9d\u00e9 par :: ou par NomClasse:: si la fonction est d\u00e9finie dans une classe","title":"Function types"},{"location":"tp0/#fonctions-comme-parametres-lambda-expressions","text":"val res2 = appl ( p , q , { a , b -> a * b }) { a , b -> a * b } C'est une lambda expression qui d\u00e9signe une fonction sans nom avec les arguments a, b. Le compilateur d\u00e9duit le type de param\u00e8tres de la d\u00e9finition de appl(). Lambda expression avec le type de param\u00e8tres : { a : Int , b : Int -> val x = a - b x * x } La valeur de lambda expression est la derni\u00e8re valeur calcul\u00e9e dans le corps de la fonction. Si lambda expression est le dernier argument d'une fonction alors on peut la mettre en dehors des parenth\u00e8ses. val q = listOf ( 2 , 6 , 8 , 99 ) val p = listOf < Int > ( - 1 , 7 , 90 , 14 ) val res2 = appl ( p , q ) { a , b -> ( a - b ) * ( a - b ) }","title":"Fonctions comme param\u00e8tres, lambda-expressions"},{"location":"tp0/#travail-a-rendre","text":"Exercice Dans Android Studio, cr\u00e9ez l\u2019application TP01. Suivez les instructions donn\u00e9es dans ce TP pour cr\u00e9er une application \u00e0 ex\u00e9cuter sur un terminal. Hello Pour voir si votre application est correctement g\u00e9n\u00e9r\u00e9e dans AndroidStudio mettre dans la fonction main() l\u2019affichage de \"Hello\" et tester si votre programme s\u2019ex\u00e9cute correctement. classe Point D\u00e9finir la classe Point qui correspond \u00e0 un point sur le, plan avec les coordonn\u00e9es enti\u00e8res x et y. La classe Point sera d\u00e9clar\u00e9 comme data class. distance \u00c9crire la fonction distance qui prend comme argument deux points et calcule la distance entre eux. On suppose que la distance entre les point p et q est |p.x \u2212 q.x| + |p.y \u2212 q.y| (donc c\u2019est un Int).. classe Rectangle La classe Rectangle repr\u00e9sente un rectangle sur le plan dont les sommets ont les coordonn\u00e9es enti\u00e8res. Un tel rectangle est d\u00e9finie de fa\u00e7o,n unique par deux de ses sommets, le sommet p en bas \u00e0 gauche et q en haut \u00e0 droite. \u00c9crire la classe Rectangle avec un constructeur qui prend comme param\u00e8tres les points p et q. Les valeurs par d\u00e9faut pour les deux points sont respectivement (0, 0) et (1, 1). Red\u00e9finir la m\u00e9thode toString() de Rectangle pour qu\u2019elle retourne \"p=$p q=$q\". D\u00e9finir dans main() un Array compos\u00e9e de plusieurs rectangles. Pour d\u00e9finir les rectangles utilisez aussi les valeurs par d\u00e9faut (un rectangles avec p et q par d\u00e9faut, un rectangle avec la valeur p par d\u00e9faut et q d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, un rectangle avec la valeur q par d\u00e9faut et p d\u00e9fini \u00e0 la cr\u00e9ation de rectangle, etc.) Dans la classe Rectangle ajouter la m\u00e9thode surface qui retourne la surface de rectangle. Dans main afficher la surface de chaque rectangle qui est dans le tableau d\u00e9fini pr\u00e9c\u00e9demment.","title":"Travail \u00e0 rendre"},{"location":"tp1/","text":"Cr\u00e9ation des interfaces graphiques et navigation Objectifs du TP Dans ce TP nous allons : D\u00e9couvrir Android Studio. D\u00e9couvrir les ressources, layouts et vues. Cr\u00e9er des interfaces graphiques simples. Naviguer entre les interfaces \u00e0 travers les intents. Exercice 1 Objectif Le but de cet exercice est de construire une interface utilisateur pr\u00e9sentant plusieurs composants graphiques Android (View). Cette interface permet de faire une authentification en demandant un couple (email, mot de passe). Apr\u00e8s appui sur le bouton Connecter, un message indique si le couple donn\u00e9 convient ou pas. Activit\u00e9-1 Indiquer les composants graphiques Android qui interviennent dans cette IHM. Activit\u00e9-2 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9. Comportement d\u2019un EditText EditText est une sous-classe de TextView qui h\u00e9rite donc de toutes les fonctions d'un TextView. De plus, cet outil dispose de nouvelles fonctionnalit\u00e9s permettant \u00e0 l'utilisateur de saisir ou de modifier le texte \u00e0 des fins diverses. Par cons\u00e9quent, il est n\u00e9cessaire de sp\u00e9cificier un type de donn\u00e9e qui peut accepter via l'attribut android:inputType. D\u00e9clarer un EditText dans votre classe MainActivity lateinit var txtEmail : EditText Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut editEmail en lui associant l'element EditText cr\u00e9\u00e9 dans le main.xml txtEmail = findViewById ( R . id . editTextEmail ) Ajouter le code suivant pour avoir la valeur de l'EditText: var email = txtEmail . text . toString () R\u00e9action aux interactions utilisateur Il existe 3 fa\u00e7ons pour manipuler le comportement d'un bouton sur Android: M\u00e9thode 1: Surcharge du Listener du bouton Cr\u00e9er un attribut dans votre activit\u00e9 de type Button : lateinit var btnLogin : Button Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut btnLogin en lui associant le bouton cr\u00e9\u00e9 dans le main.xml btnLogin = findViewById ( R . id . btnLogin ) Utiliser le code suivant pour d\u00e9finir le comportement du bouton btnLogin btnLogin . setOnClickListener { view -> // Do some work here } M\u00e8thode 2: D\u00e9finition d\u2019une m\u00e9thode propre au bouton ajouter l\u2019attribut onClick dans l'element Button dans le fichier xml : android:onClick=\"login\" Une erreur s'affiche indiquant que vous devez cr\u00e9er la m\u00e9thode login dans la classe MainActivity Cr\u00e8er la public void login ( View v ){ // Do some work here } M\u00e8thode 3: Impl\u00e9mentation de l\u2019interface OnClickListener Il est possible d\u2019utiliser l\u2019h\u00e9ritage pour surcharger la m\u00e9thode onClick, sans passer par l\u2019appel \u00e0 la m\u00e9thode setOnClickListener. Il suffit de suivre les \u00e9tapes suivantes : 1. Votre activity doit impl\u00e9menter l\u2019interface OnClickListener. Ceci est r\u00e9alis\u00e9 comme suit : class MainActivity : AppCompatActivity (), View . OnClickListener { ... } 1. Il vous demande alors d'implementer la m\u00e9thode onClick. Cliquer sur \" implement members \" et suiver les \u00e9tapes. Attention Cette m\u00e9thode sera commune \u00e0 tous les \u00e9l\u00e9ments cliquables, il faut donc distinguer le comportement selon l\u2018identifiant de l\u2018\u00e9l\u00e9ment cliqu\u00e9. Ajouter le code suivant : if ( view ? . id == R . id . btnLogin ){ // do some work } Activit\u00e9-3 Ecrire le code Kotlin qui, lorsque le bouton Connecter est actionn\u00e9 par l'utilisateur, une v\u00e9rification d'authentification est faite et un message affiche le r\u00e9sultat (bon couple login, mot de passe ou pas). Pour simplifier, on consid\u00e8re que le couple (gl4@insat.tn/insat2022) est correct. Info Pour afficher le message, utiliser un Toast . Comportement d\u2019une CheckBox La CheckBox est un bouton avec deux \u00e9tats checked (coch\u00e9s) et unchecked (non coch\u00e9s), c'est un composant de base et est tr\u00e8s souvent utilis\u00e9 dans les applications Android. Par d\u00e9faut, la CheckBox a un \u00e9tat unchecked, vous pouvez changer son \u00e9tat via la propri\u00e9t\u00e9 android:checked. <CheckBox android:id= \"@+id/someId\" android:checked= \"true\" ... /> Quelques propri\u00e9t\u00e9s importantes de CheckBox: Exercice 2 : Intent explicite Objectif Nous allons modifier le code cr\u00e9e dans l'exercice 1 de telle sorte que lorsqu'on clique sur le bouton, une nouvelle Activit\u00e9 affichant un message de Bienvenue s'ouvre. Nous allons donc utiliser un intent explicite Cr\u00e9er une Nouvelle Activity \"WelcomeActivity\" -------- Modifier le code dans la m\u00e9thode onClick pour cr\u00e9er un Intent val intent = Intent ( view . context , WelcomeActivity :: class . java ) Pour passer des param\u00e9tres \u00e0 la deuxi\u00e8me Activit\u00e9, on utilise la m\u00e9thode putExtra() qui prend en param\u00e8tres le nom du variable \u00e0 stoquer dans l'intent et sa valeur : intent . putExtra ( \"email\" , email ) Lancer la deuxi\u00e8me Activit\u00e9 startActivity ( intent ) Dans l'Activit\u00e9 WelcomeActivity ajouter le code suivant pour r\u00e9cup\u00e9rer la valeur de l'email. val email = intent . getStringExtra ( \"email\" ) Ajouter un TextView dans le ficher xml, lui attribuer un id et l'initialiser comme on a fait dans l'exercice 1. Afficher le message de Bienvenue. txtWelcome . text = \"Bienvenue $email\" Exercice 3 : Intent implicite Objectif Nous allons cr\u00e9er une application qui ouvre la galerie de photo pour choisir une image et l\u2019afficher Activit\u00e9-1 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9. Exercice 4 : Travail \u00e0 rendre Votre premier travail sera divis\u00e9 en 2 parties : En premier lieu, vous allez d\u00e9couvrir le material design, le c\u00e9l\u00e8bre langage visuel d\u00e9fini par Google. Commencer par consulter sa documentation officielle ici . Lire attentivement les diff\u00e9rentes recommandations et bonnes pratiques dict\u00e9es par Google pour la conception d\u2019interfaces graphiques. En deuxi\u00e8me lieu, vous allez appliquer ce patron et les notions vues dans ce TP sur une simple application de commande de pizza dans un restaurant. L'application aura une interface principale, o\u00f9 l'utilisateur doit introduire son nom, pr\u00e9nom et son adresse, choisir le type de pizza qu'il veut commander (Moyenne, Mini, Maxi) et les ingr\u00e9dients \u00e0 ajouter (Fromage, champignon, etc.). L'application doit lui permettre ensuite d'envoyer un SMS (ou un email) au vendeur, contenant un r\u00e9capitulatif de la commande. Ajouter ensuite une interface d'accueil (Splash Screen) qui s'affiche pendant 5 secondes puis redirige l'utilisateur \u00e0 l'interface principale.","title":"TP1: Cr\u00e9ation des interfaces graphiques et navigation"},{"location":"tp1/#creation-des-interfaces-graphiques-et-navigation","text":"","title":"Cr\u00e9ation des interfaces graphiques et navigation"},{"location":"tp1/#objectifs-du-tp","text":"Dans ce TP nous allons : D\u00e9couvrir Android Studio. D\u00e9couvrir les ressources, layouts et vues. Cr\u00e9er des interfaces graphiques simples. Naviguer entre les interfaces \u00e0 travers les intents.","title":"Objectifs du TP"},{"location":"tp1/#exercice-1","text":"","title":"Exercice 1"},{"location":"tp1/#objectif","text":"Le but de cet exercice est de construire une interface utilisateur pr\u00e9sentant plusieurs composants graphiques Android (View). Cette interface permet de faire une authentification en demandant un couple (email, mot de passe). Apr\u00e8s appui sur le bouton Connecter, un message indique si le couple donn\u00e9 convient ou pas. Activit\u00e9-1 Indiquer les composants graphiques Android qui interviennent dans cette IHM. Activit\u00e9-2 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.","title":"Objectif"},{"location":"tp1/#comportement-dun-edittext","text":"EditText est une sous-classe de TextView qui h\u00e9rite donc de toutes les fonctions d'un TextView. De plus, cet outil dispose de nouvelles fonctionnalit\u00e9s permettant \u00e0 l'utilisateur de saisir ou de modifier le texte \u00e0 des fins diverses. Par cons\u00e9quent, il est n\u00e9cessaire de sp\u00e9cificier un type de donn\u00e9e qui peut accepter via l'attribut android:inputType. D\u00e9clarer un EditText dans votre classe MainActivity lateinit var txtEmail : EditText Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut editEmail en lui associant l'element EditText cr\u00e9\u00e9 dans le main.xml txtEmail = findViewById ( R . id . editTextEmail ) Ajouter le code suivant pour avoir la valeur de l'EditText: var email = txtEmail . text . toString ()","title":"Comportement d\u2019un EditText"},{"location":"tp1/#reaction-aux-interactions-utilisateur","text":"Il existe 3 fa\u00e7ons pour manipuler le comportement d'un bouton sur Android:","title":"R\u00e9action aux interactions utilisateur"},{"location":"tp1/#methode-1-surcharge-du-listener-du-bouton","text":"Cr\u00e9er un attribut dans votre activit\u00e9 de type Button : lateinit var btnLogin : Button Dans la m\u00e9thode onCreate(), initialiser l\u2019attribut btnLogin en lui associant le bouton cr\u00e9\u00e9 dans le main.xml btnLogin = findViewById ( R . id . btnLogin ) Utiliser le code suivant pour d\u00e9finir le comportement du bouton btnLogin btnLogin . setOnClickListener { view -> // Do some work here }","title":"M\u00e9thode 1: Surcharge du Listener du bouton"},{"location":"tp1/#methode-2-definition-dune-methode-propre-au-bouton","text":"ajouter l\u2019attribut onClick dans l'element Button dans le fichier xml : android:onClick=\"login\" Une erreur s'affiche indiquant que vous devez cr\u00e9er la m\u00e9thode login dans la classe MainActivity Cr\u00e8er la public void login ( View v ){ // Do some work here }","title":"M\u00e8thode 2: D\u00e9finition d\u2019une m\u00e9thode propre au bouton"},{"location":"tp1/#methode-3-implementation-de-linterface-onclicklistener","text":"Il est possible d\u2019utiliser l\u2019h\u00e9ritage pour surcharger la m\u00e9thode onClick, sans passer par l\u2019appel \u00e0 la m\u00e9thode setOnClickListener. Il suffit de suivre les \u00e9tapes suivantes : 1. Votre activity doit impl\u00e9menter l\u2019interface OnClickListener. Ceci est r\u00e9alis\u00e9 comme suit : class MainActivity : AppCompatActivity (), View . OnClickListener { ... } 1. Il vous demande alors d'implementer la m\u00e9thode onClick. Cliquer sur \" implement members \" et suiver les \u00e9tapes. Attention Cette m\u00e9thode sera commune \u00e0 tous les \u00e9l\u00e9ments cliquables, il faut donc distinguer le comportement selon l\u2018identifiant de l\u2018\u00e9l\u00e9ment cliqu\u00e9. Ajouter le code suivant : if ( view ? . id == R . id . btnLogin ){ // do some work } Activit\u00e9-3 Ecrire le code Kotlin qui, lorsque le bouton Connecter est actionn\u00e9 par l'utilisateur, une v\u00e9rification d'authentification est faite et un message affiche le r\u00e9sultat (bon couple login, mot de passe ou pas). Pour simplifier, on consid\u00e8re que le couple (gl4@insat.tn/insat2022) est correct. Info Pour afficher le message, utiliser un Toast .","title":"M\u00e8thode 3: Impl\u00e9mentation de l\u2019interface OnClickListener"},{"location":"tp1/#comportement-dune-checkbox","text":"La CheckBox est un bouton avec deux \u00e9tats checked (coch\u00e9s) et unchecked (non coch\u00e9s), c'est un composant de base et est tr\u00e8s souvent utilis\u00e9 dans les applications Android. Par d\u00e9faut, la CheckBox a un \u00e9tat unchecked, vous pouvez changer son \u00e9tat via la propri\u00e9t\u00e9 android:checked. <CheckBox android:id= \"@+id/someId\" android:checked= \"true\" ... /> Quelques propri\u00e9t\u00e9s importantes de CheckBox:","title":"Comportement d\u2019une CheckBox"},{"location":"tp1/#exercice-2-intent-explicite","text":"","title":"Exercice 2 : Intent explicite"},{"location":"tp1/#objectif_1","text":"Nous allons modifier le code cr\u00e9e dans l'exercice 1 de telle sorte que lorsqu'on clique sur le bouton, une nouvelle Activit\u00e9 affichant un message de Bienvenue s'ouvre. Nous allons donc utiliser un intent explicite Cr\u00e9er une Nouvelle Activity \"WelcomeActivity\" -------- Modifier le code dans la m\u00e9thode onClick pour cr\u00e9er un Intent val intent = Intent ( view . context , WelcomeActivity :: class . java ) Pour passer des param\u00e9tres \u00e0 la deuxi\u00e8me Activit\u00e9, on utilise la m\u00e9thode putExtra() qui prend en param\u00e8tres le nom du variable \u00e0 stoquer dans l'intent et sa valeur : intent . putExtra ( \"email\" , email ) Lancer la deuxi\u00e8me Activit\u00e9 startActivity ( intent ) Dans l'Activit\u00e9 WelcomeActivity ajouter le code suivant pour r\u00e9cup\u00e9rer la valeur de l'email. val email = intent . getStringExtra ( \"email\" ) Ajouter un TextView dans le ficher xml, lui attribuer un id et l'initialiser comme on a fait dans l'exercice 1. Afficher le message de Bienvenue. txtWelcome . text = \"Bienvenue $email\"","title":"Objectif"},{"location":"tp1/#exercice-3-intent-implicite","text":"","title":"Exercice 3 : Intent implicite"},{"location":"tp1/#objectif_2","text":"Nous allons cr\u00e9er une application qui ouvre la galerie de photo pour choisir une image et l\u2019afficher Activit\u00e9-1 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.","title":"Objectif"},{"location":"tp1/#exercice-4-travail-a-rendre","text":"Votre premier travail sera divis\u00e9 en 2 parties : En premier lieu, vous allez d\u00e9couvrir le material design, le c\u00e9l\u00e8bre langage visuel d\u00e9fini par Google. Commencer par consulter sa documentation officielle ici . Lire attentivement les diff\u00e9rentes recommandations et bonnes pratiques dict\u00e9es par Google pour la conception d\u2019interfaces graphiques. En deuxi\u00e8me lieu, vous allez appliquer ce patron et les notions vues dans ce TP sur une simple application de commande de pizza dans un restaurant. L'application aura une interface principale, o\u00f9 l'utilisateur doit introduire son nom, pr\u00e9nom et son adresse, choisir le type de pizza qu'il veut commander (Moyenne, Mini, Maxi) et les ingr\u00e9dients \u00e0 ajouter (Fromage, champignon, etc.). L'application doit lui permettre ensuite d'envoyer un SMS (ou un email) au vendeur, contenant un r\u00e9capitulatif de la commande. Ajouter ensuite une interface d'accueil (Splash Screen) qui s'affiche pendant 5 secondes puis redirige l'utilisateur \u00e0 l'interface principale.","title":"Exercice 4 : Travail \u00e0 rendre"},{"location":"tp2/","text":"E\u0301le\u0301ments graphiques avanc\u00e9s - Adaptateurs et Listes Objectifs du TP Dans ce TP nous allons appliquer la notion d\u2019adaptateur via des exemples de listes. Rappel Adaptateurs & AdapterView Un objet adaptateur agit comme un pont entre une vue (appel\u00e9e AdapterView) et les donn\u00e9es sous-jacentes de cette vue. Une AdapterView est une vue complexe qui contient plusieurs vues, et qui n\u00e9cessite un adaptateur pour construire ses vues filles. Les AdapterViews les plus connues sont : ListView, GridView et Spinner. Un adaptateur permet de transformer les donn\u00e9es d\u2019un DataSource (un tableau ou un curseur) en widgets pour les ins\u00e9rer dans une AdapterView. Les deux types d\u2019adaptateurs les plus communs sont : ArrayAdapter et SimpleCursorAdapter: ArrayAdapter : Utiliser cet adaptateur quand votre source de donn\u00e9es est un tableau. Par d\u00e9faut, cet adaptateur cr\u00e9e une vue pour chaque \u00e9l\u00e9ment du tableau en appelant la m\u00e9thode toString de chaque \u00e9l\u00e9ment, et en pla\u00e7ant son contenu dans un objet TextView. Un adaptateur de type ArrayAdapter est cr\u00e9\u00e9 comme suit : val adapter = ArrayAdapter < String > ( this , android . R . layout . simple_list_item_1 , myStringArray ); Les arguments du constructeur sont : Le contexte de l\u2019application (repr\u00e9sente en g\u00e9n\u00e9ral l\u2019activit\u00e9 dans laquelle la AdapterView est cr\u00e9\u00e9e) Un layout repr\u00e9sentant le type d\u2019un \u00e9l\u00e9ment de la liste : Ce layout android.R.layout.simple_list_item_1 est un layout pr\u00e9d\u00e9fini qui contient un TextView pour chaque \u00e9l\u00e9ment du tableau Le tableau de cha\u00eenes de caract\u00e8res repr\u00e9sentant les donn\u00e9es \u00e0 ins\u00e9rer dans la liste. L\u2019adaptateur cr\u00e9\u00e9 sera ensuite associ\u00e9 \u00e0 la AdapterView correspondante, en utilisant la m\u00e9thode setAdapter. Il est possible de repr\u00e9senter autre chose qu\u2019un TextView pour un \u00e9l\u00e9ment de la liste. Il suffit pour cela d\u2019\u00e9tendre la classe ArrayAdapter et de surcharger la m\u00e9thode getView. Un exemple expliquant cela sera repr\u00e9sent\u00e9 plus loin dans l\u2019\u00e9nonc\u00e9. SimpleCursorAdapter : Utiliser cet adaptateur quand les donn\u00e9es sont issues d\u2019un Cursor. Cette interface fournit un acc\u00e8s al\u00e9atoire en lecture/\u00e9criture au r\u00e9sultat fourni par une requ\u00eate sur une base de donn\u00e9es. Nous n\u2019aborderons pas cet adaptateur dans ce document. Pour plus d\u2019informations, consulter la documentation officielle d\u2019Android : ici Activit\u00e9-1 Indiquer les composants graphiques Android qui interviennent dans cette IHM. Activit\u00e9-2 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9. Exercice 1. Objectif L'objectif de ce TP est de r\u00e9aliser une application simple, qui affiche la pr\u00e9sence des \u00e9tudiants dans plusieurs cours et recherche un \u00e9tudiant par son nom ou son pr\u00e9nom. Le r\u00e9sultat qu\u2019on d\u00e9sire avoir est le suivant : 2. Spinner Dans votre layout, ins\u00e9rer un Spinner. Vous trouverez ce widget dans la cat\u00e9gorie Containers de votre palette. On l\u2019appellera spinner. Le code obtenu dans votre layout XML sera comme suit : <Spinner android:layout_width= \"match_parent\" android:id= \"@+id/spinner\" app:layout_constraintLeft_toLeftOf= \"parent\" app:layout_constraintRight_toRightOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" android:layout_height= \"wrap_content\" > </Spinner> Dans votre activity, d\u00e9clarer un Spinner. Pour cr\u00e9er un objet qui sera initialis\u00e9 au premier acc\u00e8s \u00e0 celui-ci, on peut utiliser la m\u00e9thode lazy. val spinner : Spinner by lazy { findViewById ( R . id . spinner ) } Dans la m\u00e9thode onCreate(), indiquer dans un tableau la liste des mati\u00e8res qui vous seront propos\u00e9es comme suggestions : var matieres = listOf < String > ( \"Cours\" , \"TP\" ) Associer un adaptateur \u00e0 ce widget, de type ArrayAdapter. Noter que le layout utilis\u00e9 comme type pour un \u00e9l\u00e9ment de la liste est un simple_dropdown_item_1line. spinner . adapter = ArrayAdapter < String > ( this , android . R . layout . simple_dropdown_item_1line , matieres ) Pour g\u00e9rer les clics sur un \u00e9lement d'un spinner, on utilise la m\u00e9thode 'onItemSelectedListener' . Il faut surchager les m\u00e9thodes 'onItemSelected et 'onNothingSelected' . spinner . onItemSelectedListener = object : AdapterView . OnItemSelectedListener { override fun onItemSelected ( adapterView : AdapterView <*>? , view : View ? , position : Int , id : Long ) { } override fun onNothingSelected ( adapterView : AdapterView <*>? ) { } } Les param\u00e8tres de la m\u00e9thode onItemSelected sont : adapterView : L'AdapterView qui contient la vue sur laquelle le clic a \u00e9t\u00e9 effectu\u00e9. a \u00e9t\u00e9 effectu\u00e9. view : La vue.( l'item ) i : La position de la vue dans la liste. id : L'identifiant de la vue. Activit\u00e9-1 Cr\u00e9er un Spinner. Au clic sur un \u00e9l\u00e9ment de la liste, afficher un toast. 3. RecyclerView Pour afficher des \u00e9l\u00e9ments dans un recyclerview, il faut d\u00e9finir : La source de donn\u00e9es \u00e0 afficher. Un RecyclerView pour la liste d\u00e9roulante qui contient les \u00e9l\u00e9ments de la liste La ligne individuelle , dans un fichier xml \u00e0 part. Un layoutManager RecyclerView.LayoutManager g\u00e8re la disposition des \u00e9l\u00e9ments de la liste qu'il contient. Cette disposition peut \u00eatre verticale, horizontale ou une grille. Un adaptateur RecyclerView.Adapter connecte vos donn\u00e9es \u00e0 RecyclerView. Il pr\u00e9pare les donn\u00e9es dans un RecyclerView.ViewHolder. Un ViewHolder \u00c0 l'int\u00e9rieur de votre adaptateur, vous allez cr\u00e9er un ViewHolder qui contient les informations de vue pour afficher un \u00e9l\u00e9ment de la liste. Le sch\u00e9ma ci-dessous montre la relation entre les donn\u00e9es, l'adaptateur, le ViewHolder et le layoutManager. Activit\u00e9-2 Ajouter un \u00e9l\u00e9ment RecyclerView dans le fichier de layout xml au dessous du Spinner. D\u00e9finir une classe Student qui represente un Etudiant defini par son nom, son pr\u00e9nom et son genre. Cr\u00e9er un fichier layout XML (student_item.xml) pour un \u00e9l\u00e9ment de liste, qui contient une image et un Text \u00e0 droite de l'image. Suiver les \u00e9tapes indiqu\u00e9es dans le cours pour impl\u00e9menter un adaptateur. Choisir des images qui represente une femme et un homme ici , les t\u00e9l\u00e9charger et les placer dans le dossier drawable. Faire le changement n\u00e9cessaire dans la m\u00e9thode onBindViewHolder pour afficher une image selon le genre de l'etudiant. Pour cela utiliser la m\u00e9thode setImageResource(R.drawable.nom_de_limage) Dans votre Activity, connecter toutes les pi\u00e8ces pour afficher vos donn\u00e9es. Faire les changements n\u00e9cessaires au niveau du Spinner, pour afficher \u00e0 chaque fois la liste des \u00e9tudiants qui concerne une mati\u00e8re pr\u00e9cise. Pour filtrer la liste, il suffit d'implementer l'interface Filterable, au niveau de votre adaptateur et de surchager la m\u00e9thode getFilter() Ajouter un nouveau tableau dans votre adaptateur comme suit : var dataFilterList = ArrayList < Student > () init { // associer le tableau des donn\u00e9es initiales dataFilterList = data } Impl\u00e9menter l'interface Filterable et ajouter les lignes de codes suivantes : override fun getFilter (): Filter { return object : Filter (){ override fun performFiltering ( constraint : CharSequence ? ): FilterResults { val charSearch = constraint . toString () if ( charSearch . isEmpty ()) { dataFilterList = data } else { val resultList = ArrayList < Student > () for ( student in data ) { if ( student . firtName . lowercase ( Locale . ROOT ) . contains ( charSearch . lowercase ( Locale . ROOT )) ) { resultList . add ( student ) } } dataFilterList = resultList } val filterResults = FilterResults () filterResults . values = dataFilterList return filterResults } override fun publishResults ( constraint : CharSequence ? , results : FilterResults ? ) { dataFilterList = results ? . values as ArrayList < Student > notifyDataSetChanged () } } } Activit\u00e9-3 Ajouter un Editext au dessus du RecyclerView et faire le travail nec\u00e9ssaire pour permettre la recherche d'un \u00e9tudiant par nom. Info Utiliser la m\u00e9thode addTextChangedListener avec l'interface TextWatcher de la m\u00eame mani\u00e8re utilis\u00e9e dans le Spinner. Exercice 4 : Travail \u00e0 rendre Nous souhaitons que l'application permettera un enseignant de suivre l'\u00e9tat de pr\u00e9sence des \u00e9tudiants. Faire le travail necessaire pour qu'un ensignant peut : Voir l'etat de chaque \u00e9tudiant ( Absent - Pr\u00e9sent) ( Pensez \u00e0 utiliser un checkbox ) Changer l'etat d'un \u00e9tudiant Filtrer la liste selon l'etat ( Absent - Pr\u00e9sent)","title":"TP2: E\u0301le\u0301ments Graphiques avanc\u00e9s : RecyclerView"},{"location":"tp2/#elements-graphiques-avances-adaptateurs-et-listes","text":"","title":"E\u0301le\u0301ments graphiques avanc\u00e9s - Adaptateurs et Listes"},{"location":"tp2/#objectifs-du-tp","text":"Dans ce TP nous allons appliquer la notion d\u2019adaptateur via des exemples de listes.","title":"Objectifs du TP"},{"location":"tp2/#rappel","text":"","title":"Rappel"},{"location":"tp2/#adaptateurs-adapterview","text":"Un objet adaptateur agit comme un pont entre une vue (appel\u00e9e AdapterView) et les donn\u00e9es sous-jacentes de cette vue. Une AdapterView est une vue complexe qui contient plusieurs vues, et qui n\u00e9cessite un adaptateur pour construire ses vues filles. Les AdapterViews les plus connues sont : ListView, GridView et Spinner. Un adaptateur permet de transformer les donn\u00e9es d\u2019un DataSource (un tableau ou un curseur) en widgets pour les ins\u00e9rer dans une AdapterView. Les deux types d\u2019adaptateurs les plus communs sont : ArrayAdapter et SimpleCursorAdapter: ArrayAdapter : Utiliser cet adaptateur quand votre source de donn\u00e9es est un tableau. Par d\u00e9faut, cet adaptateur cr\u00e9e une vue pour chaque \u00e9l\u00e9ment du tableau en appelant la m\u00e9thode toString de chaque \u00e9l\u00e9ment, et en pla\u00e7ant son contenu dans un objet TextView. Un adaptateur de type ArrayAdapter est cr\u00e9\u00e9 comme suit : val adapter = ArrayAdapter < String > ( this , android . R . layout . simple_list_item_1 , myStringArray ); Les arguments du constructeur sont : Le contexte de l\u2019application (repr\u00e9sente en g\u00e9n\u00e9ral l\u2019activit\u00e9 dans laquelle la AdapterView est cr\u00e9\u00e9e) Un layout repr\u00e9sentant le type d\u2019un \u00e9l\u00e9ment de la liste : Ce layout android.R.layout.simple_list_item_1 est un layout pr\u00e9d\u00e9fini qui contient un TextView pour chaque \u00e9l\u00e9ment du tableau Le tableau de cha\u00eenes de caract\u00e8res repr\u00e9sentant les donn\u00e9es \u00e0 ins\u00e9rer dans la liste. L\u2019adaptateur cr\u00e9\u00e9 sera ensuite associ\u00e9 \u00e0 la AdapterView correspondante, en utilisant la m\u00e9thode setAdapter. Il est possible de repr\u00e9senter autre chose qu\u2019un TextView pour un \u00e9l\u00e9ment de la liste. Il suffit pour cela d\u2019\u00e9tendre la classe ArrayAdapter et de surcharger la m\u00e9thode getView. Un exemple expliquant cela sera repr\u00e9sent\u00e9 plus loin dans l\u2019\u00e9nonc\u00e9. SimpleCursorAdapter : Utiliser cet adaptateur quand les donn\u00e9es sont issues d\u2019un Cursor. Cette interface fournit un acc\u00e8s al\u00e9atoire en lecture/\u00e9criture au r\u00e9sultat fourni par une requ\u00eate sur une base de donn\u00e9es. Nous n\u2019aborderons pas cet adaptateur dans ce document. Pour plus d\u2019informations, consulter la documentation officielle d\u2019Android : ici Activit\u00e9-1 Indiquer les composants graphiques Android qui interviennent dans cette IHM. Activit\u00e9-2 Construire cette IHM avec Android Studio. Lancer l\u2019\u00e9mulateur, et v\u00e9rifier que le rendu correspond \u00e0 ce qui est demand\u00e9.","title":"Adaptateurs &amp; AdapterView"},{"location":"tp2/#exercice","text":"","title":"Exercice"},{"location":"tp2/#1-objectif","text":"L'objectif de ce TP est de r\u00e9aliser une application simple, qui affiche la pr\u00e9sence des \u00e9tudiants dans plusieurs cours et recherche un \u00e9tudiant par son nom ou son pr\u00e9nom. Le r\u00e9sultat qu\u2019on d\u00e9sire avoir est le suivant :","title":"1. Objectif"},{"location":"tp2/#2-spinner","text":"Dans votre layout, ins\u00e9rer un Spinner. Vous trouverez ce widget dans la cat\u00e9gorie Containers de votre palette. On l\u2019appellera spinner. Le code obtenu dans votre layout XML sera comme suit : <Spinner android:layout_width= \"match_parent\" android:id= \"@+id/spinner\" app:layout_constraintLeft_toLeftOf= \"parent\" app:layout_constraintRight_toRightOf= \"parent\" app:layout_constraintTop_toTopOf= \"parent\" android:layout_height= \"wrap_content\" > </Spinner> Dans votre activity, d\u00e9clarer un Spinner. Pour cr\u00e9er un objet qui sera initialis\u00e9 au premier acc\u00e8s \u00e0 celui-ci, on peut utiliser la m\u00e9thode lazy. val spinner : Spinner by lazy { findViewById ( R . id . spinner ) } Dans la m\u00e9thode onCreate(), indiquer dans un tableau la liste des mati\u00e8res qui vous seront propos\u00e9es comme suggestions : var matieres = listOf < String > ( \"Cours\" , \"TP\" ) Associer un adaptateur \u00e0 ce widget, de type ArrayAdapter. Noter que le layout utilis\u00e9 comme type pour un \u00e9l\u00e9ment de la liste est un simple_dropdown_item_1line. spinner . adapter = ArrayAdapter < String > ( this , android . R . layout . simple_dropdown_item_1line , matieres ) Pour g\u00e9rer les clics sur un \u00e9lement d'un spinner, on utilise la m\u00e9thode 'onItemSelectedListener' . Il faut surchager les m\u00e9thodes 'onItemSelected et 'onNothingSelected' . spinner . onItemSelectedListener = object : AdapterView . OnItemSelectedListener { override fun onItemSelected ( adapterView : AdapterView <*>? , view : View ? , position : Int , id : Long ) { } override fun onNothingSelected ( adapterView : AdapterView <*>? ) { } } Les param\u00e8tres de la m\u00e9thode onItemSelected sont : adapterView : L'AdapterView qui contient la vue sur laquelle le clic a \u00e9t\u00e9 effectu\u00e9. a \u00e9t\u00e9 effectu\u00e9. view : La vue.( l'item ) i : La position de la vue dans la liste. id : L'identifiant de la vue. Activit\u00e9-1 Cr\u00e9er un Spinner. Au clic sur un \u00e9l\u00e9ment de la liste, afficher un toast.","title":"2. Spinner"},{"location":"tp2/#3-recyclerview","text":"Pour afficher des \u00e9l\u00e9ments dans un recyclerview, il faut d\u00e9finir : La source de donn\u00e9es \u00e0 afficher. Un RecyclerView pour la liste d\u00e9roulante qui contient les \u00e9l\u00e9ments de la liste La ligne individuelle , dans un fichier xml \u00e0 part. Un layoutManager RecyclerView.LayoutManager g\u00e8re la disposition des \u00e9l\u00e9ments de la liste qu'il contient. Cette disposition peut \u00eatre verticale, horizontale ou une grille. Un adaptateur RecyclerView.Adapter connecte vos donn\u00e9es \u00e0 RecyclerView. Il pr\u00e9pare les donn\u00e9es dans un RecyclerView.ViewHolder. Un ViewHolder \u00c0 l'int\u00e9rieur de votre adaptateur, vous allez cr\u00e9er un ViewHolder qui contient les informations de vue pour afficher un \u00e9l\u00e9ment de la liste. Le sch\u00e9ma ci-dessous montre la relation entre les donn\u00e9es, l'adaptateur, le ViewHolder et le layoutManager. Activit\u00e9-2 Ajouter un \u00e9l\u00e9ment RecyclerView dans le fichier de layout xml au dessous du Spinner. D\u00e9finir une classe Student qui represente un Etudiant defini par son nom, son pr\u00e9nom et son genre. Cr\u00e9er un fichier layout XML (student_item.xml) pour un \u00e9l\u00e9ment de liste, qui contient une image et un Text \u00e0 droite de l'image. Suiver les \u00e9tapes indiqu\u00e9es dans le cours pour impl\u00e9menter un adaptateur. Choisir des images qui represente une femme et un homme ici , les t\u00e9l\u00e9charger et les placer dans le dossier drawable. Faire le changement n\u00e9cessaire dans la m\u00e9thode onBindViewHolder pour afficher une image selon le genre de l'etudiant. Pour cela utiliser la m\u00e9thode setImageResource(R.drawable.nom_de_limage) Dans votre Activity, connecter toutes les pi\u00e8ces pour afficher vos donn\u00e9es. Faire les changements n\u00e9cessaires au niveau du Spinner, pour afficher \u00e0 chaque fois la liste des \u00e9tudiants qui concerne une mati\u00e8re pr\u00e9cise. Pour filtrer la liste, il suffit d'implementer l'interface Filterable, au niveau de votre adaptateur et de surchager la m\u00e9thode getFilter() Ajouter un nouveau tableau dans votre adaptateur comme suit : var dataFilterList = ArrayList < Student > () init { // associer le tableau des donn\u00e9es initiales dataFilterList = data } Impl\u00e9menter l'interface Filterable et ajouter les lignes de codes suivantes : override fun getFilter (): Filter { return object : Filter (){ override fun performFiltering ( constraint : CharSequence ? ): FilterResults { val charSearch = constraint . toString () if ( charSearch . isEmpty ()) { dataFilterList = data } else { val resultList = ArrayList < Student > () for ( student in data ) { if ( student . firtName . lowercase ( Locale . ROOT ) . contains ( charSearch . lowercase ( Locale . ROOT )) ) { resultList . add ( student ) } } dataFilterList = resultList } val filterResults = FilterResults () filterResults . values = dataFilterList return filterResults } override fun publishResults ( constraint : CharSequence ? , results : FilterResults ? ) { dataFilterList = results ? . values as ArrayList < Student > notifyDataSetChanged () } } } Activit\u00e9-3 Ajouter un Editext au dessus du RecyclerView et faire le travail nec\u00e9ssaire pour permettre la recherche d'un \u00e9tudiant par nom. Info Utiliser la m\u00e9thode addTextChangedListener avec l'interface TextWatcher de la m\u00eame mani\u00e8re utilis\u00e9e dans le Spinner.","title":"3. RecyclerView"},{"location":"tp2/#exercice-4-travail-a-rendre","text":"Nous souhaitons que l'application permettera un enseignant de suivre l'\u00e9tat de pr\u00e9sence des \u00e9tudiants. Faire le travail necessaire pour qu'un ensignant peut : Voir l'etat de chaque \u00e9tudiant ( Absent - Pr\u00e9sent) ( Pensez \u00e0 utiliser un checkbox ) Changer l'etat d'un \u00e9tudiant Filtrer la liste selon l'etat ( Absent - Pr\u00e9sent)","title":"Exercice 4 : Travail \u00e0 rendre"},{"location":"tp3/","text":"Fragments & Menus Objectifs du TP Dans ce TP nous allons travailler avec les fragments et les menus. Rappel Fragment Un fragment repr\u00e9sente un comportement ou une portion d\u2019interface utilisateur dans une activit\u00e9. Il est possible de combiner plusieurs fragments dans une seule activit\u00e9 pour construire une interface \u00e0 plusieurs panneaux, et r\u00e9utiliser un fragment dans plusieurs activit\u00e9s. Un fragment a son propre cycle de vie, re\u00e7oit ses propres entr\u00e9es et peut \u00eatre ajout\u00e9, modifi\u00e9 ou supprim\u00e9 de mani\u00e8re dynamique. Il est toujours inclus dans une activit\u00e9, et son cycle de vie est directement affect\u00e9 par celui de l\u2019activit\u00e9 qui le contient. Tant que l\u2019activit\u00e9 conteneur est en \u00e9tat d\u2019ex\u00e9cution, le fragment peut \u00eatre manipul\u00e9 de mani\u00e8re ind\u00e9pendante (ajout\u00e9, modifi\u00e9 ou supprim\u00e9). Mais si l\u2019activit\u00e9 est d\u00e9truite, le fragment l\u2019est aussi. A la base, les fragments ont \u00e9t\u00e9 cr\u00e9\u00e9s pour supporter la conception d\u2019interfaces graphiques flexibles sur des \u00e9crans de tailles diff\u00e9rentes, et permettre ainsi aux appareils dont la taille d\u2019\u00e9cran est plus importante (comme les tablettes) de profiter de cet espace pour combiner et inter-changer des composants graphiques. Cr\u00e9ation d'un fragment Pour cr\u00e9er un fragment, il faut cr\u00e9er une classe qui h\u00e9rite de android.app.Fragment, ou une de ses sous-classes. Parmi ces sous-classes on peut citer: DialogFragment : Affiche une bo\u00eete de dialogue flottante au lieu d\u2019utiliser des m\u00e9thodes dans votre activit\u00e9, car il peut \u00eatre rajout\u00e9 \u00e0 la pile des fragments de l\u2019activit\u00e9. ListFragment: Affiche une liste d\u2019\u00e9l\u00e9ments g\u00e9r\u00e9s par un adaptateur, et fournit ainsi plusieurs m\u00e9thodes pour g\u00e9rer une listView. PreferenceFragment: Affiche une hi\u00e9rarchie d\u2019objets Preference comme liste. Permet de cr\u00e9er une activit\u00e9 de type settings pour votre application. Pour cr\u00e9er un fragment, il faut suivre les \u00e9tapes suivantes : 1. Cr\u00e9er un nouveau fragment \u00e0 l'aide de Android Studio. 2. Ajouter le fragment \u00e0 une activit\u00e9 Le fragment peut \u00eatre ajout\u00e9 de mani\u00e8re statique ou dynamique \u00e0 l\u2019activit\u00e9. Statique : D\u00e9clarer le fragment dans le fichier layout XML de l\u2019activit\u00e9, gr\u00e2ce \u00e0 l\u2019\u00e9l\u00e9ment XML androidx.fragment.app.FragmentContainerView . Pour cela, indiquer comme attribut android:name la classe Java du fragment \u00e0 instancier dans le layout. Dans ce cas on ne peut pas g\u00e9rer (remplacer,supprimer, ajouter) notre fragment \u00e0 l'ex\u00e9cution. Dynamique : Dans ce cas, on peut g\u00e9rer notre fragment \u00e0 l'ex\u00e9cution, en d\u00e9clarant un FrameLayout dans le fichier layout XML de l'activit\u00e9. Pour g\u00e9rer notre fragment on doit utiliser un FragmentManager . Un FragmentManager permet de g\u00e9rer les fragments d\u2019une activit\u00e9 particuli\u00e8re. Pour l\u2019utiliser, il suffit d\u2019appeler directement supportFragmentManager \u00e0 partir de n\u2019importe quel emplacement de votre activit\u00e9. Le FragmentManager permet de : Manipuler les fragments existants dans votre application gr\u00e2ce aux m\u00e9thodes findFragmentById() ou findFragmentByTag() G\u00e9rer la pile de retour (Back Stack), accessible via le bouton Back de l\u2019appareil D\u00e9piler un fragment de la pile, avec popBackStack() Associer un Listener aux changements de cette pile avec addOnBackStackChangedListener() La manipulation des fragments par le FragmentManager est possible gr\u00e2ce \u00e0 un ensemble de FragmentTransactions. Une transaction est une op\u00e9ration sur des fragments (ajout, suppression, remplacement\u2026) dans une activit\u00e9, en r\u00e9ponse \u00e0 une interaction utilisateur. Une transaction peut \u00eatre stock\u00e9e dans la pile de retour de l\u2019activit\u00e9, pour permettre \u00e0 l\u2019utilisateur de revenir en arri\u00e8re, gr\u00e2ce \u00e0 la m\u00e9thode addToBackStack(). II. Exercice 1 : Fragments 1. Objectif L\u2019objectif de cet exercice est de montrer comment cr\u00e9er et inter-changer des fragments dans une application Android. L\u2019objectif est d\u2019obtenir le r\u00e9sultat suivant : 2. Cr\u00e9ation des fragments Pour cr\u00e9er les fragments, commencer par : Cr\u00e9er une application avec une simple activit\u00e9 vide. Cr\u00e9er le layout pour le premier fragment. Pour cela, cr\u00e9er un fichier frag_digital.xml sous le r\u00e9pertoire layout, y ins\u00e9rer un objet AnalogClock, et utiliser la couleur d\u2019arri\u00e8re plan de votre choix Faire de m\u00eame pour cr\u00e9er un fragment frag_numeric avec une horloge de type TextClock Cr\u00e9er une classe FragmentClock qui \u00e9tend la classe Fragment. La premi\u00e8re chose \u00e0 faire est d\u2019impl\u00e9menter la m\u00e9thode onCreateView qui repr\u00e9sente le comportement du fragment d\u00e8s son apparition. Dans cette m\u00e9thode, nous allons indiquer quel fragment charger. Pour charger le fragment frag_digital, par exemple, la m\u00e9thode onCreateView doit retourner : inflater . inflate ( R . layout . frag_digital , container , false ); Laisser l \u2019impl\u00e9mentation de cette partie pour plus tard. 3. Cr\u00e9ation de l\u2019activit\u00e9 principale Pour cr\u00e9er l\u2019activit\u00e9 principale : Commencer par cr\u00e9er son interface. Pour cela, commencer par ins\u00e9rer un switch et un bouton c\u00f4te \u00e0 c\u00f4te. Le bouton d\u00e9finit comme m\u00e9thode onClick la fonction : setTime Cr\u00e9er une balise androidx.fragment.app.FragmentContainerView qui va contenir le fragment en question. <androidx.fragment.app.FragmentContainerView android:id= \"@+id/fragment\" android:layout_width= \"match_parent\" android:layout_height= \"0dp\" app:layout_constraintBottom_toBottomOf= \"parent\" > </androidx.fragment.app.FragmentContainerView> L\u2019objectif \u00e9tant de cliquer sur le bouton Set, puis d\u2019afficher l\u2019horloge digitale si le switch est activ\u00e9, et l\u2019horloge num\u00e9rique s\u2019il est d\u00e9sactiv\u00e9. Il faut donc maintenant impl\u00e9menter la fonction setTime. public void setTime ( View view ) { var fragmentManager = supportFragmentManager var transaction = fragmentManager . beginTransaction () var fragmentClock = FragmentClock () var bundle = Bundle () bundle . putBoolean ( \"digitalOK\" , binding . switchWidget . isChecked ) fragmentClock . arguments = bundle transaction . replace ( R . id . fragment , fragmentClock ) transaction . commit () } L\u2019objet Bundle permet d\u2019envoyer une ensemble de param\u00e8tres, sous format clef/valeur, au fragment. En l\u2019occurrence, dans notre cas, nous allons lui envoyer l\u2019\u00e9tat du switch (checked ou unchecked), dans le param\u00e8tre bool\u00e9en digitalOK. Le fragment manager va se charger de placer le fragment \u00e0 l\u2019endroit qui lui est associ\u00e9, soit dans la balise FragmentContainerView Pour d\u00e9finir quel fragment charger, modifier le code de la classe FragmentClock comme suit : private const val IS_DIGITAL = \"digitalOK\" class FragmentClock : Fragment () { // TODO: Rename and change types of parameters private var digitalClock = true override fun onCreate ( savedInstanceState : Bundle ? ) { super . onCreate ( savedInstanceState ) arguments ? . let { digitalClock = it . getBoolean ( IS_DIGITAL ) } } override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup ? , savedInstanceState : Bundle ? ): View ? { return if ( ! digitalClock ) inflater . inflate ( R . layout . fragment_numeric , container , false ) else inflater . inflate ( R . layout . fragment_digital , container , false ) } } Initielemnt : Au moment du lancement de notre activit\u00e9, on doit ins\u00e9rer notre fragment dynamiquement pour pouvoir le remplacer ult\u00e9rieurement. Pour cela on doit utiliser le FragmentManager dans la m\u00e9thode onCreate de l'activit\u00e9. supportFragmentManager . beginTransaction () . replace ( R . id . fragment , FragmentClock (), null ) . addToBackStack ( null ) . commit () Activit\u00e9 1 R\u00e9aliser l\u2019application comme indiqu\u00e9 dans les \u00e9tapes pr\u00e9c\u00e9dentes. Lancer l\u2019\u00e9mulateur pour tester votre code. III. Menus 1. Menus d\u2019options et Action Bar Les APIs Menu \u00e9taient \u00e0 la base destin\u00e9es \u00e0 d\u00e9finir le comportement (entre autres) du bouton menu du t\u00e9l\u00e9phone qui, depuis la version 3.0 est devenu obsol\u00e8te. \u00c9tant donn\u00e9 que plusieurs terminaux r\u00e9cents ne poss\u00e8dent plus ce bouton, il a \u00e9t\u00e9 n\u00e9cessaire de remplacer ce type de menus. D\u00e9sormais, les fonctionnalit\u00e9s du menu d\u2019options sont d\u00e9finies dans le Action Bar: La barre d'action (Action Bar) est une caract\u00e9ristique qui identifie l'emplacement de l'utilisateur et lui fournit des actions et des modes de navigation. Elle fournit un espace d\u00e9di\u00e9 pour donner \u00e0 votre application une identit\u00e9 et indiquer o\u00f9 se trouve l\u2019utilisateur dans l\u2019application, un ensemble d\u2019actions importantes est accessibles comme la recherche par exemple, une navigation consistante et la possibilit\u00e9 de changer de vue dans une application gr\u00e2ce aux tabulations ou listes d\u00e9roulantes. Dans les applications que vous cr\u00e9ez par d\u00e9faut avec Android Studio, vous allez trouver une barre d\u2019action qui est ajout\u00e9e automatiquement. Le contenu de cette barre est d\u00e9crit dans un fichier XML que vous trouverez sous le r\u00e9pertoire menu. Chaque \u00e9l\u00e9ment de la barre sera repr\u00e9sent\u00e9 comme un nouvel item. L\u2019attribut showAsAction permet de configurer l\u2019apparition de l\u2019\u00e9l\u00e9ment dans la barre ou bien dans le Action Overflow ( ). Plusieurs valeurs sont possibles, dont : never, always ou ifRoom. Pour d\u00e9finir le comportement des \u00e9l\u00e9ments de la barre d\u2019action, il faut impl\u00e9menter les m\u00e9thodes (automatiquement g\u00e9n\u00e9r\u00e9es): onCreateOptionsMenu : construit le menu en appelant le contenu du menu XML onOptionsItemSelected : d\u00e9finit le comportement de chacune des actions de la barre IV. Exercice 2 : Action Bar 1. Objectif L\u2019objectif est d\u2019ajouter des \u00e9l\u00e9ments \u00e0 la barre d\u2019actions de l\u2019exercice pr\u00e9c\u00e9dent. Le rendu final sera comme suit : 2. Impl\u00e9mentation Cr\u00e9er un nouveau dossier de ressources sous le dossier res et choisir le type de fichier menu . Sous le dossier menu cr\u00e9e, cr\u00e9er un nouveau fichier Menu Ressource File . Ajouter dans le fichier un \u00e9l\u00e9ment switch, et associez-lui une ic\u00f4ne, en pr\u00e9cisant qu\u2019il doit toujours \u00eatre affich\u00e9 dans la barre d\u2019options : <item android:id= \"@+id/action_switch\" android:orderInCategory= \"100\" android:icon= \"@drawable/refresh\" app:showAsAction= \"always\" android:title= \"@string/action_refresh\" > </item> Dans votre activit\u00e9 implementer la fonction onCreateOptionsMenu , comme suit : override fun onCreateOptionsMenu ( menu : Menu ? ): Boolean { val inflater : MenuInflater = menuInflater inflater . inflate ( R . menu . menu , menu ) return true } Impl\u00e9menter la fonction onOptionsItemSelected, comme suit : override fun onOptionsItemSelected ( item : MenuItem ): Boolean { if ( item . itemId == R . id . action_switch ) { binding . switchWidget . isChecked = ! binding . switchWidget . isChecked setTime ( null ) } return super . onOptionsItemSelected ( item ) } Activit\u00e9 2 Cr\u00e9er l\u2019action Bar pr\u00e9c\u00e9dente dans votre application. V. Menu Contextuel Un menu contextuel est un menu flottant qui appara\u00eet quand un utilisateur fait un clic long sur un \u00e9l\u00e9ment, par exemple. Il fournit des actions qui affectent le contenu cliqu\u00e9 et/ou son conteneur. \u00c0 partir de la version 3 d\u2019Android, ce menu a \u00e9t\u00e9 remplac\u00e9 par un mode contextuel permettant de r\u00e9aliser des actions sur le contenu s\u00e9lectionn\u00e9. Il affiche les actions qui affectent le contenu s\u00e9lectionn\u00e9 dans une barre en haut de l\u2019\u00e9cran et permet \u00e0 l\u2019utilisateur de s\u00e9lectionner plusieurs \u00e9l\u00e9ments au besoin. En g\u00e9n\u00e9ral, on change vers le mode contextuel si l\u2019utilisateur fait un clic long sur un \u00e9l\u00e9ment, ou s\u2019il s\u00e9lectionne une case \u00e0 cocher (ou autre \u00e9l\u00e9ment \u00e9quivalent). La barre d\u2019action contextuelle prend alors momentan\u00e9ment la place de la barre d\u2019action. Il est possible d\u2019activer ce mode pour un widget individuel, ou bien pour un groupe d\u2019\u00e9l\u00e9ments regroup\u00e9s dans une liste ou une grille, par exemple. VI. Exercice 3 : Menu Contextuel 1. Objectif L\u2019objectif est d\u2019activer le mode contextuel si l\u2019utilisateur fait un appui long sur le bouton. Dans la barre contextuelle, l\u2019utilisateur pourra alors changer la couleur du bouton. 2. D\u00e9finir le Menu Contextuel Pour d\u00e9finir le contenu de la barre contextuelle, il faut ajouter un autre fichier xml dans le r\u00e9pertoire menu. On l\u2019appellera context_mode_menu.xml <menu xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" > <item android:id= \"@+id/action_color\" app:showAsAction= \"always\" android:icon= \"@drawable/color_fill\" android:title= \"@string/action_color\" > </item> </menu> 3. D\u00e9finir le Callback Impl\u00e9menter l'interface ActionMode.Callback dans votre Activit\u00e9. L\u2019impl\u00e9mentation de cette interface requiert l\u2019impl\u00e9mentation de plusieurs m\u00e9thodes, notamment : onCreateActionMode : comportement \u00e0 la cr\u00e9ation du mode contextuel onActionItemClicked : comportement au clic sur un \u00e9l\u00e9ment de la barre contextuelle onDestroyActionMode : comportement \u00e0 la fermeture du mode contextuel override fun onCreateActionMode ( actionMode : ActionMode , menu : Menu ? ): Boolean { val inflater : MenuInflater = actionMode . menuInflater inflater . inflate ( R . menu . context_mode_menu , menu ) return true } override fun onPrepareActionMode ( p0 : ActionMode ? , p1 : Menu ? ): Boolean { return true } override fun onActionItemClicked ( actionMode : ActionMode ? , menuItem : MenuItem ? ): Boolean { return when ( menuItem ? . itemId ) { R . id . action_color -> { binding . btnSet . setBackgroundColor ( resources . getColor ( R . color . teal_200 ) ) actionMode ? . finish () true } else -> false } } override fun onDestroyActionMode ( p0 : ActionMode ? ) { } 4. Associer le callback \u00e0 un \u00e9v\u00e9nement Enfin, il faut associer ce callback \u00e0 un \u00e9v\u00e9nement, notamment l\u2019appui long sur le bouton. Pour cela, \u00e9crire le code suivant dans votre activit\u00e9 : private lateinit var binding : ActivityTestFragmentBinding // code \u00e0 ajouter private lateinit var actionMode : ActionMode override fun onCreate ( savedInstanceState : Bundle ? ) { super . onCreate ( savedInstanceState ) binding = ActivityTestFragmentBinding . inflate ( layoutInflater ) setContentView ( binding . root ) supportFragmentManager . beginTransaction () . replace ( R . id . fragment , FragmentClock (), null ) . addToBackStack ( null ) . commit () // code \u00e0 ajouter binding . btnSet . setOnLongClickListener { actionMode = this @TestFragmentActivity.startActionMode ( this @TestFragmentActivity ) !! return @setOnLongClickListener true } } Activit\u00e9 3 Vous savez ce que vous avez \u00e0 faire... Homework L\u2019un des principaux avantages des fragments est la facilit\u00e9 qu\u2019ils offrent quand il s\u2019agit de s\u2019adapter \u00e0 des tailles d\u2019\u00e9crans diff\u00e9rentes. 1. Impl\u00e9menter un exemple simple montrant comment est-ce qu\u2019une application avec des fragments r\u00e9agit sur diff\u00e9rentes tailles d\u2019\u00e9cran, en utilisant les multi-pane layouts . 2. Ajouter une petite fonctionnalit\u00e9 dans la barre d\u2019options, permettant \u00e0 l\u2019application de passer d\u2019un th\u00e8me \u00e0 un autre (deux th\u00e8mes peuvent \u00eatre d\u00e9finis statiquement).","title":"TP3: Cr\u00e9ation des Fragments"},{"location":"tp3/#fragments-menus","text":"","title":"Fragments &amp; Menus"},{"location":"tp3/#objectifs-du-tp","text":"Dans ce TP nous allons travailler avec les fragments et les menus.","title":"Objectifs du TP"},{"location":"tp3/#rappel","text":"","title":"Rappel"},{"location":"tp3/#fragment","text":"Un fragment repr\u00e9sente un comportement ou une portion d\u2019interface utilisateur dans une activit\u00e9. Il est possible de combiner plusieurs fragments dans une seule activit\u00e9 pour construire une interface \u00e0 plusieurs panneaux, et r\u00e9utiliser un fragment dans plusieurs activit\u00e9s. Un fragment a son propre cycle de vie, re\u00e7oit ses propres entr\u00e9es et peut \u00eatre ajout\u00e9, modifi\u00e9 ou supprim\u00e9 de mani\u00e8re dynamique. Il est toujours inclus dans une activit\u00e9, et son cycle de vie est directement affect\u00e9 par celui de l\u2019activit\u00e9 qui le contient. Tant que l\u2019activit\u00e9 conteneur est en \u00e9tat d\u2019ex\u00e9cution, le fragment peut \u00eatre manipul\u00e9 de mani\u00e8re ind\u00e9pendante (ajout\u00e9, modifi\u00e9 ou supprim\u00e9). Mais si l\u2019activit\u00e9 est d\u00e9truite, le fragment l\u2019est aussi. A la base, les fragments ont \u00e9t\u00e9 cr\u00e9\u00e9s pour supporter la conception d\u2019interfaces graphiques flexibles sur des \u00e9crans de tailles diff\u00e9rentes, et permettre ainsi aux appareils dont la taille d\u2019\u00e9cran est plus importante (comme les tablettes) de profiter de cet espace pour combiner et inter-changer des composants graphiques.","title":"Fragment"},{"location":"tp3/#creation-dun-fragment","text":"Pour cr\u00e9er un fragment, il faut cr\u00e9er une classe qui h\u00e9rite de android.app.Fragment, ou une de ses sous-classes. Parmi ces sous-classes on peut citer: DialogFragment : Affiche une bo\u00eete de dialogue flottante au lieu d\u2019utiliser des m\u00e9thodes dans votre activit\u00e9, car il peut \u00eatre rajout\u00e9 \u00e0 la pile des fragments de l\u2019activit\u00e9. ListFragment: Affiche une liste d\u2019\u00e9l\u00e9ments g\u00e9r\u00e9s par un adaptateur, et fournit ainsi plusieurs m\u00e9thodes pour g\u00e9rer une listView. PreferenceFragment: Affiche une hi\u00e9rarchie d\u2019objets Preference comme liste. Permet de cr\u00e9er une activit\u00e9 de type settings pour votre application. Pour cr\u00e9er un fragment, il faut suivre les \u00e9tapes suivantes :","title":"Cr\u00e9ation d'un fragment"},{"location":"tp3/#1-creer-un-nouveau-fragment-a-laide-de-android-studio","text":"","title":"1. Cr\u00e9er un nouveau fragment \u00e0 l'aide de Android Studio."},{"location":"tp3/#2-ajouter-le-fragment-a-une-activite","text":"Le fragment peut \u00eatre ajout\u00e9 de mani\u00e8re statique ou dynamique \u00e0 l\u2019activit\u00e9. Statique : D\u00e9clarer le fragment dans le fichier layout XML de l\u2019activit\u00e9, gr\u00e2ce \u00e0 l\u2019\u00e9l\u00e9ment XML androidx.fragment.app.FragmentContainerView . Pour cela, indiquer comme attribut android:name la classe Java du fragment \u00e0 instancier dans le layout. Dans ce cas on ne peut pas g\u00e9rer (remplacer,supprimer, ajouter) notre fragment \u00e0 l'ex\u00e9cution. Dynamique : Dans ce cas, on peut g\u00e9rer notre fragment \u00e0 l'ex\u00e9cution, en d\u00e9clarant un FrameLayout dans le fichier layout XML de l'activit\u00e9. Pour g\u00e9rer notre fragment on doit utiliser un FragmentManager . Un FragmentManager permet de g\u00e9rer les fragments d\u2019une activit\u00e9 particuli\u00e8re. Pour l\u2019utiliser, il suffit d\u2019appeler directement supportFragmentManager \u00e0 partir de n\u2019importe quel emplacement de votre activit\u00e9. Le FragmentManager permet de : Manipuler les fragments existants dans votre application gr\u00e2ce aux m\u00e9thodes findFragmentById() ou findFragmentByTag() G\u00e9rer la pile de retour (Back Stack), accessible via le bouton Back de l\u2019appareil D\u00e9piler un fragment de la pile, avec popBackStack() Associer un Listener aux changements de cette pile avec addOnBackStackChangedListener() La manipulation des fragments par le FragmentManager est possible gr\u00e2ce \u00e0 un ensemble de FragmentTransactions. Une transaction est une op\u00e9ration sur des fragments (ajout, suppression, remplacement\u2026) dans une activit\u00e9, en r\u00e9ponse \u00e0 une interaction utilisateur. Une transaction peut \u00eatre stock\u00e9e dans la pile de retour de l\u2019activit\u00e9, pour permettre \u00e0 l\u2019utilisateur de revenir en arri\u00e8re, gr\u00e2ce \u00e0 la m\u00e9thode addToBackStack().","title":"2. Ajouter le fragment \u00e0 une activit\u00e9"},{"location":"tp3/#ii-exercice-1-fragments","text":"","title":"II. Exercice 1 : Fragments"},{"location":"tp3/#1-objectif","text":"L\u2019objectif de cet exercice est de montrer comment cr\u00e9er et inter-changer des fragments dans une application Android. L\u2019objectif est d\u2019obtenir le r\u00e9sultat suivant :","title":"1. Objectif"},{"location":"tp3/#2-creation-des-fragments","text":"Pour cr\u00e9er les fragments, commencer par : Cr\u00e9er une application avec une simple activit\u00e9 vide. Cr\u00e9er le layout pour le premier fragment. Pour cela, cr\u00e9er un fichier frag_digital.xml sous le r\u00e9pertoire layout, y ins\u00e9rer un objet AnalogClock, et utiliser la couleur d\u2019arri\u00e8re plan de votre choix Faire de m\u00eame pour cr\u00e9er un fragment frag_numeric avec une horloge de type TextClock Cr\u00e9er une classe FragmentClock qui \u00e9tend la classe Fragment. La premi\u00e8re chose \u00e0 faire est d\u2019impl\u00e9menter la m\u00e9thode onCreateView qui repr\u00e9sente le comportement du fragment d\u00e8s son apparition. Dans cette m\u00e9thode, nous allons indiquer quel fragment charger. Pour charger le fragment frag_digital, par exemple, la m\u00e9thode onCreateView doit retourner : inflater . inflate ( R . layout . frag_digital , container , false ); Laisser l \u2019impl\u00e9mentation de cette partie pour plus tard.","title":"2. Cr\u00e9ation des fragments"},{"location":"tp3/#3-creation-de-lactivite-principale","text":"Pour cr\u00e9er l\u2019activit\u00e9 principale : Commencer par cr\u00e9er son interface. Pour cela, commencer par ins\u00e9rer un switch et un bouton c\u00f4te \u00e0 c\u00f4te. Le bouton d\u00e9finit comme m\u00e9thode onClick la fonction : setTime Cr\u00e9er une balise androidx.fragment.app.FragmentContainerView qui va contenir le fragment en question. <androidx.fragment.app.FragmentContainerView android:id= \"@+id/fragment\" android:layout_width= \"match_parent\" android:layout_height= \"0dp\" app:layout_constraintBottom_toBottomOf= \"parent\" > </androidx.fragment.app.FragmentContainerView> L\u2019objectif \u00e9tant de cliquer sur le bouton Set, puis d\u2019afficher l\u2019horloge digitale si le switch est activ\u00e9, et l\u2019horloge num\u00e9rique s\u2019il est d\u00e9sactiv\u00e9. Il faut donc maintenant impl\u00e9menter la fonction setTime. public void setTime ( View view ) { var fragmentManager = supportFragmentManager var transaction = fragmentManager . beginTransaction () var fragmentClock = FragmentClock () var bundle = Bundle () bundle . putBoolean ( \"digitalOK\" , binding . switchWidget . isChecked ) fragmentClock . arguments = bundle transaction . replace ( R . id . fragment , fragmentClock ) transaction . commit () } L\u2019objet Bundle permet d\u2019envoyer une ensemble de param\u00e8tres, sous format clef/valeur, au fragment. En l\u2019occurrence, dans notre cas, nous allons lui envoyer l\u2019\u00e9tat du switch (checked ou unchecked), dans le param\u00e8tre bool\u00e9en digitalOK. Le fragment manager va se charger de placer le fragment \u00e0 l\u2019endroit qui lui est associ\u00e9, soit dans la balise FragmentContainerView Pour d\u00e9finir quel fragment charger, modifier le code de la classe FragmentClock comme suit : private const val IS_DIGITAL = \"digitalOK\" class FragmentClock : Fragment () { // TODO: Rename and change types of parameters private var digitalClock = true override fun onCreate ( savedInstanceState : Bundle ? ) { super . onCreate ( savedInstanceState ) arguments ? . let { digitalClock = it . getBoolean ( IS_DIGITAL ) } } override fun onCreateView ( inflater : LayoutInflater , container : ViewGroup ? , savedInstanceState : Bundle ? ): View ? { return if ( ! digitalClock ) inflater . inflate ( R . layout . fragment_numeric , container , false ) else inflater . inflate ( R . layout . fragment_digital , container , false ) } } Initielemnt : Au moment du lancement de notre activit\u00e9, on doit ins\u00e9rer notre fragment dynamiquement pour pouvoir le remplacer ult\u00e9rieurement. Pour cela on doit utiliser le FragmentManager dans la m\u00e9thode onCreate de l'activit\u00e9. supportFragmentManager . beginTransaction () . replace ( R . id . fragment , FragmentClock (), null ) . addToBackStack ( null ) . commit () Activit\u00e9 1 R\u00e9aliser l\u2019application comme indiqu\u00e9 dans les \u00e9tapes pr\u00e9c\u00e9dentes. Lancer l\u2019\u00e9mulateur pour tester votre code.","title":"3. Cr\u00e9ation de l\u2019activit\u00e9 principale"},{"location":"tp3/#iii-menus","text":"","title":"III. Menus"},{"location":"tp3/#1-menus-doptions-et-action-bar","text":"Les APIs Menu \u00e9taient \u00e0 la base destin\u00e9es \u00e0 d\u00e9finir le comportement (entre autres) du bouton menu du t\u00e9l\u00e9phone qui, depuis la version 3.0 est devenu obsol\u00e8te. \u00c9tant donn\u00e9 que plusieurs terminaux r\u00e9cents ne poss\u00e8dent plus ce bouton, il a \u00e9t\u00e9 n\u00e9cessaire de remplacer ce type de menus. D\u00e9sormais, les fonctionnalit\u00e9s du menu d\u2019options sont d\u00e9finies dans le Action Bar: La barre d'action (Action Bar) est une caract\u00e9ristique qui identifie l'emplacement de l'utilisateur et lui fournit des actions et des modes de navigation. Elle fournit un espace d\u00e9di\u00e9 pour donner \u00e0 votre application une identit\u00e9 et indiquer o\u00f9 se trouve l\u2019utilisateur dans l\u2019application, un ensemble d\u2019actions importantes est accessibles comme la recherche par exemple, une navigation consistante et la possibilit\u00e9 de changer de vue dans une application gr\u00e2ce aux tabulations ou listes d\u00e9roulantes. Dans les applications que vous cr\u00e9ez par d\u00e9faut avec Android Studio, vous allez trouver une barre d\u2019action qui est ajout\u00e9e automatiquement. Le contenu de cette barre est d\u00e9crit dans un fichier XML que vous trouverez sous le r\u00e9pertoire menu. Chaque \u00e9l\u00e9ment de la barre sera repr\u00e9sent\u00e9 comme un nouvel item. L\u2019attribut showAsAction permet de configurer l\u2019apparition de l\u2019\u00e9l\u00e9ment dans la barre ou bien dans le Action Overflow ( ). Plusieurs valeurs sont possibles, dont : never, always ou ifRoom. Pour d\u00e9finir le comportement des \u00e9l\u00e9ments de la barre d\u2019action, il faut impl\u00e9menter les m\u00e9thodes (automatiquement g\u00e9n\u00e9r\u00e9es): onCreateOptionsMenu : construit le menu en appelant le contenu du menu XML onOptionsItemSelected : d\u00e9finit le comportement de chacune des actions de la barre","title":"1. Menus d\u2019options et Action Bar"},{"location":"tp3/#iv-exercice-2-action-bar","text":"","title":"IV. Exercice 2 : Action Bar"},{"location":"tp3/#1-objectif_1","text":"L\u2019objectif est d\u2019ajouter des \u00e9l\u00e9ments \u00e0 la barre d\u2019actions de l\u2019exercice pr\u00e9c\u00e9dent. Le rendu final sera comme suit :","title":"1. Objectif"},{"location":"tp3/#2-implementation","text":"Cr\u00e9er un nouveau dossier de ressources sous le dossier res et choisir le type de fichier menu . Sous le dossier menu cr\u00e9e, cr\u00e9er un nouveau fichier Menu Ressource File . Ajouter dans le fichier un \u00e9l\u00e9ment switch, et associez-lui une ic\u00f4ne, en pr\u00e9cisant qu\u2019il doit toujours \u00eatre affich\u00e9 dans la barre d\u2019options : <item android:id= \"@+id/action_switch\" android:orderInCategory= \"100\" android:icon= \"@drawable/refresh\" app:showAsAction= \"always\" android:title= \"@string/action_refresh\" > </item> Dans votre activit\u00e9 implementer la fonction onCreateOptionsMenu , comme suit : override fun onCreateOptionsMenu ( menu : Menu ? ): Boolean { val inflater : MenuInflater = menuInflater inflater . inflate ( R . menu . menu , menu ) return true } Impl\u00e9menter la fonction onOptionsItemSelected, comme suit : override fun onOptionsItemSelected ( item : MenuItem ): Boolean { if ( item . itemId == R . id . action_switch ) { binding . switchWidget . isChecked = ! binding . switchWidget . isChecked setTime ( null ) } return super . onOptionsItemSelected ( item ) } Activit\u00e9 2 Cr\u00e9er l\u2019action Bar pr\u00e9c\u00e9dente dans votre application.","title":"2. Impl\u00e9mentation"},{"location":"tp3/#v-menu-contextuel","text":"Un menu contextuel est un menu flottant qui appara\u00eet quand un utilisateur fait un clic long sur un \u00e9l\u00e9ment, par exemple. Il fournit des actions qui affectent le contenu cliqu\u00e9 et/ou son conteneur. \u00c0 partir de la version 3 d\u2019Android, ce menu a \u00e9t\u00e9 remplac\u00e9 par un mode contextuel permettant de r\u00e9aliser des actions sur le contenu s\u00e9lectionn\u00e9. Il affiche les actions qui affectent le contenu s\u00e9lectionn\u00e9 dans une barre en haut de l\u2019\u00e9cran et permet \u00e0 l\u2019utilisateur de s\u00e9lectionner plusieurs \u00e9l\u00e9ments au besoin. En g\u00e9n\u00e9ral, on change vers le mode contextuel si l\u2019utilisateur fait un clic long sur un \u00e9l\u00e9ment, ou s\u2019il s\u00e9lectionne une case \u00e0 cocher (ou autre \u00e9l\u00e9ment \u00e9quivalent). La barre d\u2019action contextuelle prend alors momentan\u00e9ment la place de la barre d\u2019action. Il est possible d\u2019activer ce mode pour un widget individuel, ou bien pour un groupe d\u2019\u00e9l\u00e9ments regroup\u00e9s dans une liste ou une grille, par exemple.","title":"V. Menu Contextuel"},{"location":"tp3/#vi-exercice-3-menu-contextuel","text":"","title":"VI. Exercice 3 : Menu Contextuel"},{"location":"tp3/#1-objectif_2","text":"L\u2019objectif est d\u2019activer le mode contextuel si l\u2019utilisateur fait un appui long sur le bouton. Dans la barre contextuelle, l\u2019utilisateur pourra alors changer la couleur du bouton.","title":"1. Objectif"},{"location":"tp3/#2-definir-le-menu-contextuel","text":"Pour d\u00e9finir le contenu de la barre contextuelle, il faut ajouter un autre fichier xml dans le r\u00e9pertoire menu. On l\u2019appellera context_mode_menu.xml <menu xmlns:android= \"http://schemas.android.com/apk/res/android\" xmlns:app= \"http://schemas.android.com/apk/res-auto\" > <item android:id= \"@+id/action_color\" app:showAsAction= \"always\" android:icon= \"@drawable/color_fill\" android:title= \"@string/action_color\" > </item> </menu>","title":"2. D\u00e9finir le Menu Contextuel"},{"location":"tp3/#3-definir-le-callback","text":"Impl\u00e9menter l'interface ActionMode.Callback dans votre Activit\u00e9. L\u2019impl\u00e9mentation de cette interface requiert l\u2019impl\u00e9mentation de plusieurs m\u00e9thodes, notamment : onCreateActionMode : comportement \u00e0 la cr\u00e9ation du mode contextuel onActionItemClicked : comportement au clic sur un \u00e9l\u00e9ment de la barre contextuelle onDestroyActionMode : comportement \u00e0 la fermeture du mode contextuel override fun onCreateActionMode ( actionMode : ActionMode , menu : Menu ? ): Boolean { val inflater : MenuInflater = actionMode . menuInflater inflater . inflate ( R . menu . context_mode_menu , menu ) return true } override fun onPrepareActionMode ( p0 : ActionMode ? , p1 : Menu ? ): Boolean { return true } override fun onActionItemClicked ( actionMode : ActionMode ? , menuItem : MenuItem ? ): Boolean { return when ( menuItem ? . itemId ) { R . id . action_color -> { binding . btnSet . setBackgroundColor ( resources . getColor ( R . color . teal_200 ) ) actionMode ? . finish () true } else -> false } } override fun onDestroyActionMode ( p0 : ActionMode ? ) { }","title":"3. D\u00e9finir le Callback"},{"location":"tp3/#4-associer-le-callback-a-un-evenement","text":"Enfin, il faut associer ce callback \u00e0 un \u00e9v\u00e9nement, notamment l\u2019appui long sur le bouton. Pour cela, \u00e9crire le code suivant dans votre activit\u00e9 : private lateinit var binding : ActivityTestFragmentBinding // code \u00e0 ajouter private lateinit var actionMode : ActionMode override fun onCreate ( savedInstanceState : Bundle ? ) { super . onCreate ( savedInstanceState ) binding = ActivityTestFragmentBinding . inflate ( layoutInflater ) setContentView ( binding . root ) supportFragmentManager . beginTransaction () . replace ( R . id . fragment , FragmentClock (), null ) . addToBackStack ( null ) . commit () // code \u00e0 ajouter binding . btnSet . setOnLongClickListener { actionMode = this @TestFragmentActivity.startActionMode ( this @TestFragmentActivity ) !! return @setOnLongClickListener true } } Activit\u00e9 3 Vous savez ce que vous avez \u00e0 faire...","title":"4. Associer le callback \u00e0 un \u00e9v\u00e9nement"},{"location":"tp3/#homework","text":"L\u2019un des principaux avantages des fragments est la facilit\u00e9 qu\u2019ils offrent quand il s\u2019agit de s\u2019adapter \u00e0 des tailles d\u2019\u00e9crans diff\u00e9rentes. 1. Impl\u00e9menter un exemple simple montrant comment est-ce qu\u2019une application avec des fragments r\u00e9agit sur diff\u00e9rentes tailles d\u2019\u00e9cran, en utilisant les multi-pane layouts . 2. Ajouter une petite fonctionnalit\u00e9 dans la barre d\u2019options, permettant \u00e0 l\u2019application de passer d\u2019un th\u00e8me \u00e0 un autre (deux th\u00e8mes peuvent \u00eatre d\u00e9finis statiquement).","title":"Homework"},{"location":"tp4/","text":"","title":"TP4: Stockage de donn\u00e9es et Firebase"},{"location":"tp5/","text":"","title":"Tp5"},{"location":"tp6/","text":"TP 5 Connexion \u00e0 des services web REST Objectifs du TP Interrogation de services web REST \u00e0 partir de votre application Android avec la biblioth\u00e8que Retrofit en suivant l'architecture MVVM. I. Les web services Un service Web est une norme utilis\u00e9e pour \u00e9changer des informations entre des applications ou des syst\u00e8mes de type h\u00e9t\u00e9rog\u00e8ne. Les applications logicielles \u00e9crites dans divers langages de programmation et s'ex\u00e9cutant sur diverses plates-formes peuvent utiliser des services Web pour \u00e9changer des informations sur Internet \u00e0 l'aide du protocole http. 1.Le besoin d'utiliser le service Web dans les applications Android Les applications Web existantes ont \u00e9galement besoin de cr\u00e9er des applications mobiles pour montrer leur pr\u00e9sence dans la plate-forme mobile. Exposer les fonctionnalit\u00e9s existantes des applications est un peu difficile car toutes les fonctionnalit\u00e9s doivent \u00eatre r\u00e9\u00e9crites dans les plates-formes respectives. Mais il peut \u00eatre facilement r\u00e9alis\u00e9 avec beaucoup de facilit\u00e9 en cr\u00e9ant un service Web et en exposant les fonctionnalit\u00e9s existantes en tant que m\u00e9thodes Web aux plateformes mobiles. Voici les quelques avantages de l'utilisation de Web Service sous Android: - Rendre le client plus l\u00e9ger. - R\u00e9utilisation des fonctionnalit\u00e9s existantes. - Utilisation d'une base de donn\u00e9es distante. Voici une architecture simplif\u00e9e d'une application Android qui utilise des web services : II. Retrofit Retrofit est un client REST pour Android et Java, permettant de grouper et organiser toutes vos APIs de mani\u00e8re simple et propre. Les annotations sont utilis\u00e9es pour contr\u00f4ler les param\u00e8tres d\u2019appel de l\u2019API, d\u00e9finies dans des interfaces, que vous appelez \u00e0 partir de classes. Toutes les APIs http sont repr\u00e9sent\u00e9es sous forme d\u2019interfaces, comme suit : 1. D\u00e9claration d\u2019APIs : Chaque m\u00e9thode doit avoir une annotation http qui fournit la m\u00e9thode utilis\u00e9e ainsi que l\u2019URL. 5 annotations sont fournies : GET, POST, PUT, DELETE et HEAD. Voici un exemple d\u2019appel : Il est possible de sp\u00e9cifier les param\u00e8tres de la requ\u00eate dans l\u2019URL : Pour un remplacement dynamique de blocs et de param\u00e8tres dans la m\u00e9thode, utiliser : {}, puis r\u00e9f\u00e9rencer ce bloc avec l\u2019annotation @ PATH, comme suit : Il est \u00e9galement possible d\u2019utiliser des param\u00e8tres de requ\u00eates (query parameters) comme suit : L\u2019URL r\u00e9sultante sera alors comme suit : group/id_val/users ?sort=sort_val Pour ins\u00e9rer plusieurs param\u00e8tres de requ\u00eate \u00e0 la fois, utiliser une Map: Consulter le site de Retrofit pour plus d\u2019exemples d\u2019utilisation de Retrofit. 2. Format de Donn\u00e9es Par d\u00e9faut, Retrofit peut seulement d\u00e9-s\u00e9rialiser les HTTP bodies en objets ResponseBody de la biblioth\u00e8que OkHttp, et n\u2019accepte les requ\u00eates que sous format RequestBody pour le @Body. Cependant, un ensemble de convertisseurs sont disponibles pour supporter d\u2019autres types, dont Gson. Gson est une librairie Java utilis\u00e9e pour convertir les objets Java en leur repr\u00e9sentation JSON, et vice-versa. Pour supporter Retrofit, il faut d\u2019abord ajouter deux d\u00e9pendances : Librairie Retrofit Gson Activit\u00e9 1 Cr\u00e9er un projet Android TP5. Ajouter les d\u00e9pendances pour Retrofit et gson dans le fichier build.gradle (du Module), en ins\u00e9rant les lignes suivantes dans la partie dependencies: implementation(\"com.squareup.retrofit2:retrofit:2.9.0\") implementation 'com.squareup.retrofit2:converter-gson:2.3.0 N\u2019oubliez pas de synchroniser le projet pour que les d\u00e9pendances soient prises en compte ! III. Exercice : Acc\u00e8s \u00e0 un Service Web 1. Objectif Dur\u00e9e estim\u00e9e de l\u2019exercice : 2h L\u2019objectif de ce TP est de r\u00e9aliser une application android qui acc\u00e8de \u00e0 des donn\u00e9es provenant d\u2019un service web externe. 2. G\u00e9n\u00e9ration des classes data \u00e0 partir des donn\u00e9es JSON Le service web que nous appelons est un service public de consultation de m\u00e9t\u00e9o. Pour consulter la m\u00e9t\u00e9o actuelle \u00e0 Tunis, nous utilisons l\u2019URI suivante : http://api.openweathermap.org/data/2.5/weather?q=Tunis&APPID=17db59488cadcad345211c36304a9266 La r\u00e9ponse obtenue ressemble \u00e0 la suivante : Pour obtenir un APPID valide, il suffit de s\u2019inscrire sur le site http://openweathermap.org , un APPID sera g\u00e9n\u00e9r\u00e9 pour vous, vous le trouverez dans votre profil. Il suffira ensuite de remplacer le APPID de l\u2019URI pr\u00e9c\u00e9dente par la votre. Une fois une r\u00e9ponse valide obtenue, sous la forme d\u2019un document JSON comme le montre la figure pr\u00e9c\u00e9dente, il est possible de g\u00e9n\u00e9rer les classes POJO que vous allez utiliser pour manipuler les donn\u00e9es du service web \u00e0 votre guise. Pour cela : \u2022 Copier la r\u00e9ponse que vous obtenez de l'API \u2022 Faites un clic droit sur le package et s\u00e9lectionnez New-> Kotlin-data class from JSON \u2022 Donner \u00e0 ce fichier un nom appropri\u00e9. \u2022 7 classes de donn\u00e9es seront g\u00e9n\u00e9r\u00e9es. 3. Cr\u00e9ation de l\u2019interface graphique Commencer par cr\u00e9er l'interface graphique suivante : Ajouter \u00e9galement, dans le fichier Manifest, la permission d\u2019acc\u00e8s \u00e0 internet : <uses-permission android:name= \"android.permission.INTERNET\" /> 4. Interface RestInterface \u2022 Cr\u00e9er une interface appel\u00e9e RestInterface dans votre projet. Cette interface permettra de mapper une URI donn\u00e9e \u00e0 un appel de m\u00e9thode, gr\u00e2ce aux annotations fournies par l\u2019API Retrofit. \u2022 Pour obtenir la m\u00e9t\u00e9o de Tunis, le code de RestInterface devra \u00eatre comme suit : interface WeatherAPI { @GET ( \"weather?q=Tunis&APPID=17db59488cadcad345211c36304a9266\" ) fun getWeather () : Call < WeatherResponse > } Vous remarquerez ici que l\u2019URI commence par weather. En effet, le path principal sera indiqu\u00e9 dans la classe principale, lors de l\u2019appel du service. 5. Retrofit Builder Cr\u00e9er une nouvelle classe RetrofitHelper et y ins\u00e9rer le code suivant. Retrofit Builder nous permet de construire la requ\u00eate: object RetrofitHelper { private const val baseUrl = \"https://api.openweathermap.org/data/2.5/\" /** * The Retrofit object with Gson converter. */ private val retrofit = Retrofit . Builder (). baseUrl ( baseUrl ) . addConverterFactory ( GsonConverterFactory . create ()) // we need to add converter factory to // convert JSON object to Java object . build () /** * A public Api object that exposes the lazy-initialized Retrofit service */ val retrofitService : WeatherAPI by lazy { retrofit . create ( WeatherAPI :: class . java ) } } Info En Kotlin, les d\u00e9clarations d'objets servent \u00e0 d\u00e9clarer des objets singleton. Le sch\u00e9ma singleton garantit qu'une seule et unique instance d'un objet est cr\u00e9\u00e9e et qu'elle poss\u00e8de un point d'acc\u00e8s global \u00e0 cet objet. Le langage Kotlin permet de d\u00e9clarer facilement des singletons. Vous trouverez ci-dessous un exemple de d\u00e9claration d'objet et de son acc\u00e8s. Le nom de la d\u00e9claration d'objet est toujours suivi du mot cl\u00e9 object (objet). // Object declaration object DataProviderManager { fun registerDataProvider ( provider : DataProvider ) { // ... } \u200b val allDataProviders : Collection < DataProvider > get () = // ... } // To refer to the object, use its name directly. DataProviderManager . registerDataProvider (...) L\u2019URL utilis\u00e9e ici est une cha\u00eene statique repr\u00e9sentant l\u2019URL principale fixe du web service http://api.openweathermap.org/data/2.5/ Activit\u00e9 2 Faire le travail n\u00e9cessaire, pour consommer l'API fournit afin d'afficher les donn\u00e9es sur la m\u00e9t\u00e9o de Tunis. Vous devez appliquer l'architecture MVVM vu en cours . 7. Ajout de param\u00e8tres Nous aimerions maintenant que l\u2019appel au web service soit param\u00e9tr\u00e9. C\u2019est \u00e0 dire que le nom de la ville dont on va afficher la m\u00e9t\u00e9o sera pass\u00e9 en param\u00e8tre \u00e0 l\u2019appel de la fonction getWeather, et non pas en dur directement dans RestInterface. Activit\u00e9 3 Ajouter un param\u00e8tre \u00e0 la fonction getWeather. 8. Liste de Choix Pour obtenir le r\u00e9sultat final, comme montr\u00e9 dans la partie II.1, il faut d\u00e9finir une liste d\u00e9roulante (spinner), dans lequel on trouvera les noms des villes dont nous voulons afficher la m\u00e9t\u00e9o. Activit\u00e9 4 Ajouter une liste d\u00e9roulante \u00e0 votre activit\u00e9. Ins\u00e9rer les noms des villes de votre choix. Modifier votre code de fa\u00e7on \u00e0 ce que l\u2019appel au service web change selon le nom de la ville s\u00e9lectionn\u00e9e. 9. Liste des pr\u00e9visions On souhaite maintenant afficher la pr\u00e9visions m\u00e9t\u00e9orologiques \u00e0 16 jours. Activit\u00e9 5 Ajouter un Button qui am\u00e8ne \u00e0 une nouvelle Activity contenant un RecyclerView qui affiche la liste des pr\u00e9visions m\u00e9trologiques de la ville selectionn\u00e9e. Penser \u00e0 utiliser l'API suivant : lien Appliquer l'architecture MVVM.","title":"TP5: Connexion \u00e0 des services web REST"},{"location":"tp6/#tp-5-connexion-a-des-services-web-rest","text":"","title":"TP 5 Connexion \u00e0 des services web REST"},{"location":"tp6/#objectifs-du-tp","text":"Interrogation de services web REST \u00e0 partir de votre application Android avec la biblioth\u00e8que Retrofit en suivant l'architecture MVVM.","title":"Objectifs du TP"},{"location":"tp6/#i-les-web-services","text":"Un service Web est une norme utilis\u00e9e pour \u00e9changer des informations entre des applications ou des syst\u00e8mes de type h\u00e9t\u00e9rog\u00e8ne. Les applications logicielles \u00e9crites dans divers langages de programmation et s'ex\u00e9cutant sur diverses plates-formes peuvent utiliser des services Web pour \u00e9changer des informations sur Internet \u00e0 l'aide du protocole http.","title":"I. Les web services"},{"location":"tp6/#1le-besoin-dutiliser-le-service-web-dans-les-applications-android","text":"Les applications Web existantes ont \u00e9galement besoin de cr\u00e9er des applications mobiles pour montrer leur pr\u00e9sence dans la plate-forme mobile. Exposer les fonctionnalit\u00e9s existantes des applications est un peu difficile car toutes les fonctionnalit\u00e9s doivent \u00eatre r\u00e9\u00e9crites dans les plates-formes respectives. Mais il peut \u00eatre facilement r\u00e9alis\u00e9 avec beaucoup de facilit\u00e9 en cr\u00e9ant un service Web et en exposant les fonctionnalit\u00e9s existantes en tant que m\u00e9thodes Web aux plateformes mobiles. Voici les quelques avantages de l'utilisation de Web Service sous Android: - Rendre le client plus l\u00e9ger. - R\u00e9utilisation des fonctionnalit\u00e9s existantes. - Utilisation d'une base de donn\u00e9es distante. Voici une architecture simplif\u00e9e d'une application Android qui utilise des web services :","title":"1.Le besoin d'utiliser le service Web dans les applications Android"},{"location":"tp6/#ii-retrofit","text":"Retrofit est un client REST pour Android et Java, permettant de grouper et organiser toutes vos APIs de mani\u00e8re simple et propre. Les annotations sont utilis\u00e9es pour contr\u00f4ler les param\u00e8tres d\u2019appel de l\u2019API, d\u00e9finies dans des interfaces, que vous appelez \u00e0 partir de classes. Toutes les APIs http sont repr\u00e9sent\u00e9es sous forme d\u2019interfaces, comme suit :","title":"II. Retrofit"},{"location":"tp6/#1-declaration-dapis","text":"Chaque m\u00e9thode doit avoir une annotation http qui fournit la m\u00e9thode utilis\u00e9e ainsi que l\u2019URL. 5 annotations sont fournies : GET, POST, PUT, DELETE et HEAD. Voici un exemple d\u2019appel : Il est possible de sp\u00e9cifier les param\u00e8tres de la requ\u00eate dans l\u2019URL : Pour un remplacement dynamique de blocs et de param\u00e8tres dans la m\u00e9thode, utiliser : {}, puis r\u00e9f\u00e9rencer ce bloc avec l\u2019annotation @ PATH, comme suit : Il est \u00e9galement possible d\u2019utiliser des param\u00e8tres de requ\u00eates (query parameters) comme suit : L\u2019URL r\u00e9sultante sera alors comme suit : group/id_val/users ?sort=sort_val Pour ins\u00e9rer plusieurs param\u00e8tres de requ\u00eate \u00e0 la fois, utiliser une Map: Consulter le site de Retrofit pour plus d\u2019exemples d\u2019utilisation de Retrofit.","title":"1. D\u00e9claration d\u2019APIs\u00a0:"},{"location":"tp6/#2-format-de-donnees","text":"Par d\u00e9faut, Retrofit peut seulement d\u00e9-s\u00e9rialiser les HTTP bodies en objets ResponseBody de la biblioth\u00e8que OkHttp, et n\u2019accepte les requ\u00eates que sous format RequestBody pour le @Body. Cependant, un ensemble de convertisseurs sont disponibles pour supporter d\u2019autres types, dont Gson. Gson est une librairie Java utilis\u00e9e pour convertir les objets Java en leur repr\u00e9sentation JSON, et vice-versa. Pour supporter Retrofit, il faut d\u2019abord ajouter deux d\u00e9pendances : Librairie Retrofit Gson Activit\u00e9 1 Cr\u00e9er un projet Android TP5. Ajouter les d\u00e9pendances pour Retrofit et gson dans le fichier build.gradle (du Module), en ins\u00e9rant les lignes suivantes dans la partie dependencies: implementation(\"com.squareup.retrofit2:retrofit:2.9.0\") implementation 'com.squareup.retrofit2:converter-gson:2.3.0 N\u2019oubliez pas de synchroniser le projet pour que les d\u00e9pendances soient prises en compte !","title":"2. Format de Donn\u00e9es"},{"location":"tp6/#iii-exercice-acces-a-un-service-web","text":"","title":"III. Exercice : Acc\u00e8s \u00e0 un Service Web"},{"location":"tp6/#1-objectif","text":"Dur\u00e9e estim\u00e9e de l\u2019exercice : 2h L\u2019objectif de ce TP est de r\u00e9aliser une application android qui acc\u00e8de \u00e0 des donn\u00e9es provenant d\u2019un service web externe.","title":"1. Objectif"},{"location":"tp6/#2-generation-des-classes-data-a-partir-des-donnees-json","text":"Le service web que nous appelons est un service public de consultation de m\u00e9t\u00e9o. Pour consulter la m\u00e9t\u00e9o actuelle \u00e0 Tunis, nous utilisons l\u2019URI suivante : http://api.openweathermap.org/data/2.5/weather?q=Tunis&APPID=17db59488cadcad345211c36304a9266 La r\u00e9ponse obtenue ressemble \u00e0 la suivante : Pour obtenir un APPID valide, il suffit de s\u2019inscrire sur le site http://openweathermap.org , un APPID sera g\u00e9n\u00e9r\u00e9 pour vous, vous le trouverez dans votre profil. Il suffira ensuite de remplacer le APPID de l\u2019URI pr\u00e9c\u00e9dente par la votre. Une fois une r\u00e9ponse valide obtenue, sous la forme d\u2019un document JSON comme le montre la figure pr\u00e9c\u00e9dente, il est possible de g\u00e9n\u00e9rer les classes POJO que vous allez utiliser pour manipuler les donn\u00e9es du service web \u00e0 votre guise. Pour cela : \u2022 Copier la r\u00e9ponse que vous obtenez de l'API \u2022 Faites un clic droit sur le package et s\u00e9lectionnez New-> Kotlin-data class from JSON \u2022 Donner \u00e0 ce fichier un nom appropri\u00e9. \u2022 7 classes de donn\u00e9es seront g\u00e9n\u00e9r\u00e9es.","title":"2. G\u00e9n\u00e9ration des classes data \u00e0 partir des donn\u00e9es JSON"},{"location":"tp6/#3-creation-de-linterface-graphique","text":"Commencer par cr\u00e9er l'interface graphique suivante : Ajouter \u00e9galement, dans le fichier Manifest, la permission d\u2019acc\u00e8s \u00e0 internet : <uses-permission android:name= \"android.permission.INTERNET\" />","title":"3. Cr\u00e9ation de l\u2019interface graphique"},{"location":"tp6/#4-interface-restinterface","text":"\u2022 Cr\u00e9er une interface appel\u00e9e RestInterface dans votre projet. Cette interface permettra de mapper une URI donn\u00e9e \u00e0 un appel de m\u00e9thode, gr\u00e2ce aux annotations fournies par l\u2019API Retrofit. \u2022 Pour obtenir la m\u00e9t\u00e9o de Tunis, le code de RestInterface devra \u00eatre comme suit : interface WeatherAPI { @GET ( \"weather?q=Tunis&APPID=17db59488cadcad345211c36304a9266\" ) fun getWeather () : Call < WeatherResponse > } Vous remarquerez ici que l\u2019URI commence par weather. En effet, le path principal sera indiqu\u00e9 dans la classe principale, lors de l\u2019appel du service.","title":"4. Interface RestInterface"},{"location":"tp6/#5-retrofit-builder","text":"Cr\u00e9er une nouvelle classe RetrofitHelper et y ins\u00e9rer le code suivant. Retrofit Builder nous permet de construire la requ\u00eate: object RetrofitHelper { private const val baseUrl = \"https://api.openweathermap.org/data/2.5/\" /** * The Retrofit object with Gson converter. */ private val retrofit = Retrofit . Builder (). baseUrl ( baseUrl ) . addConverterFactory ( GsonConverterFactory . create ()) // we need to add converter factory to // convert JSON object to Java object . build () /** * A public Api object that exposes the lazy-initialized Retrofit service */ val retrofitService : WeatherAPI by lazy { retrofit . create ( WeatherAPI :: class . java ) } } Info En Kotlin, les d\u00e9clarations d'objets servent \u00e0 d\u00e9clarer des objets singleton. Le sch\u00e9ma singleton garantit qu'une seule et unique instance d'un objet est cr\u00e9\u00e9e et qu'elle poss\u00e8de un point d'acc\u00e8s global \u00e0 cet objet. Le langage Kotlin permet de d\u00e9clarer facilement des singletons. Vous trouverez ci-dessous un exemple de d\u00e9claration d'objet et de son acc\u00e8s. Le nom de la d\u00e9claration d'objet est toujours suivi du mot cl\u00e9 object (objet). // Object declaration object DataProviderManager { fun registerDataProvider ( provider : DataProvider ) { // ... } \u200b val allDataProviders : Collection < DataProvider > get () = // ... } // To refer to the object, use its name directly. DataProviderManager . registerDataProvider (...) L\u2019URL utilis\u00e9e ici est une cha\u00eene statique repr\u00e9sentant l\u2019URL principale fixe du web service http://api.openweathermap.org/data/2.5/ Activit\u00e9 2 Faire le travail n\u00e9cessaire, pour consommer l'API fournit afin d'afficher les donn\u00e9es sur la m\u00e9t\u00e9o de Tunis. Vous devez appliquer l'architecture MVVM vu en cours .","title":"5. Retrofit Builder"},{"location":"tp6/#7-ajout-de-parametres","text":"Nous aimerions maintenant que l\u2019appel au web service soit param\u00e9tr\u00e9. C\u2019est \u00e0 dire que le nom de la ville dont on va afficher la m\u00e9t\u00e9o sera pass\u00e9 en param\u00e8tre \u00e0 l\u2019appel de la fonction getWeather, et non pas en dur directement dans RestInterface. Activit\u00e9 3 Ajouter un param\u00e8tre \u00e0 la fonction getWeather.","title":"7. Ajout de param\u00e8tres"},{"location":"tp6/#8-liste-de-choix","text":"Pour obtenir le r\u00e9sultat final, comme montr\u00e9 dans la partie II.1, il faut d\u00e9finir une liste d\u00e9roulante (spinner), dans lequel on trouvera les noms des villes dont nous voulons afficher la m\u00e9t\u00e9o. Activit\u00e9 4 Ajouter une liste d\u00e9roulante \u00e0 votre activit\u00e9. Ins\u00e9rer les noms des villes de votre choix. Modifier votre code de fa\u00e7on \u00e0 ce que l\u2019appel au service web change selon le nom de la ville s\u00e9lectionn\u00e9e.","title":"8. Liste de Choix"},{"location":"tp6/#9-liste-des-previsions","text":"On souhaite maintenant afficher la pr\u00e9visions m\u00e9t\u00e9orologiques \u00e0 16 jours. Activit\u00e9 5 Ajouter un Button qui am\u00e8ne \u00e0 une nouvelle Activity contenant un RecyclerView qui affiche la liste des pr\u00e9visions m\u00e9trologiques de la ville selectionn\u00e9e. Penser \u00e0 utiliser l'API suivant : lien Appliquer l'architecture MVVM.","title":"9. Liste des pr\u00e9visions"}]}